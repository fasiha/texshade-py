<!DOCTYPE html>

<head>
  <meta charset="utf-8">
  <title>Texshade: texture-shaded elevation via the fractional-Laplacian operator</title>
  <link rel="stylesheet" href="assets/retro.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css"
    integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js"
    integrity="sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1"
    crossorigin="anonymous"></script>

  <!-- To automatically render math in text elements, include the auto-render extension: -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js"
    integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters: [
      {left: '$$', right: '$$', display: true},
    {left: '\\(', right: '\\)', display: false}
]});"></script>

  <script>
    window.WebFontConfig = {
      custom: {
        families: ['KaTeX_AMS', 'KaTeX_Caligraphic:n4,n7', 'KaTeX_Fraktur:n4,n7',
          'KaTeX_Main:n4,n7,i4,i7', 'KaTeX_Math:i4,i7', 'KaTeX_Script',
          'KaTeX_SansSerif:n4,n7,i4', 'KaTeX_Size1', 'KaTeX_Size2', 'KaTeX_Size3',
          'KaTeX_Size4', 'KaTeX_Typewriter'],
      },
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js"
    integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script>

  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }
  </style>
  <style>
    <style>code.sourceCode>span {
      display: inline-block;
      line-height: 1.25;
    }

    code.sourceCode>span {
      color: inherit;
      text-decoration: inherit;
    }

    code.sourceCode>span:empty {
      height: 1.2em;
    }

    .sourceCode {
      overflow: visible;
    }

    code.sourceCode {
      white-space: pre;
      position: relative;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      code.sourceCode {
        white-space: pre-wrap;
      }

      code.sourceCode>span {
        text-indent: -5em;
        padding-left: 5em;
      }
    }

    pre.numberSource code {
      counter-reset: source-line 0;
    }

    pre.numberSource code>span {
      position: relative;
      left: -4em;
      counter-increment: source-line;
    }

    pre.numberSource code>span>a:first-child::before {
      content: counter(source-line);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
      background-color: #232629;
      color: #7a7c7d;
    }

    pre.numberSource {
      margin-left: 3em;
      border-left: 1px solid #7a7c7d;
      padding-left: 4px;
    }

    div.sourceCode {
      color: #cfcfc2;
      background-color: #232629;
    }

    @media screen {
      code.sourceCode>span>a:first-child::before {
        text-decoration: underline;
      }
    }

    code span. {
      color: #cfcfc2;
    }

    /* Normal */
    code span.al {
      color: #95da4c;
    }

    /* Alert */
    code span.an {
      color: #3f8058;
    }

    /* Annotation */
    code span.at {
      color: #2980b9;
    }

    /* Attribute */
    code span.bn {
      color: #f67400;
    }

    /* BaseN */
    code span.bu {
      color: #7f8c8d;
    }

    /* BuiltIn */
    code span.cf {
      color: #fdbc4b;
    }

    /* ControlFlow */
    code span.ch {
      color: #3daee9;
    }

    /* Char */
    code span.cn {
      color: #27aeae;
    }

    /* Constant */
    code span.co {
      color: #7a7c7d;
    }

    /* Comment */
    code span.cv {
      color: #7f8c8d;
    }

    /* CommentVar */
    code span.do {
      color: #a43340;
    }

    /* Documentation */
    code span.dt {
      color: #2980b9;
    }

    /* DataType */
    code span.dv {
      color: #f67400;
    }

    /* DecVal */
    code span.er {
      color: #da4453;
    }

    /* Error */
    code span.ex {
      color: #0099ff;
    }

    /* Extension */
    code span.fl {
      color: #f67400;
    }

    /* Float */
    code span.fu {
      color: #8e44ad;
    }

    /* Function */
    code span.im {
      color: #27ae60;
    }

    /* Import */
    code span.in {
      color: #c45b00;
    }

    /* Information */
    code span.kw {
      color: #cfcfc2;
    }

    /* Keyword */
    code span.op {
      color: #cfcfc2;
    }

    /* Operator */
    code span.ot {
      color: #27ae60;
    }

    /* Other */
    code span.pp {
      color: #27ae60;
    }

    /* Preprocessor */
    code span.re {
      color: #2980b9;
    }

    /* RegionMarker */
    code span.sc {
      color: #3daee9;
    }

    /* SpecialChar */
    code span.ss {
      color: #da4453;
    }

    /* SpecialString */
    code span.st {
      color: #f44f4f;
    }

    /* String */
    code span.va {
      color: #27aeae;
    }

    /* Variable */
    code span.vs {
      color: #da4453;
    }

    /* VerbatimString */
    code span.wa {
      color: #da4453;
    }

    /* Warning */
  </style>

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->

</head><h1 id="texshade-texture-shaded-elevation-via-the-fractional-laplacian-operator">Texshade: texture-shaded elevation via the fractional-Laplacian operator</h1>
<h2 id="introduction">Introduction</h2>
<p>See <a href="http://www.textureshading.com/Home.html" class="uri">http://www.textureshading.com/Home.html</a> for links to papers and slides by Leland Brown from 2010 and 2014 describing the technique of texture shading, but in summary, it is a method of processing digital elevation maps (DEMs) that highlights the network nature of topography, throwing ridges, canyons, and valleys into sharp relief.</p>
<p>This repository contains an open-source public-domain Python/Numpy software library to apply the texture shading algorithm on <em>extremely</em> large datasets. This is a challenge because a straightforward implementation of the texture-shading technique requires loading the entire elevation map into memory. For large datasets—like the ASTER Global DEM, which comes in at roughly 250 GB compressed—you either have to find a computer with a lot of memory (nodes with 1+ TB RAM are available at many scientific organizations as of 2019) or you have to modify the technique.</p>
<p>This repository contains (1) mathematical and (2) software details of a low-memory approximation to the original texture-shading algorithm that in practice produces texture-shaded imagery very similar to the full algorithm.</p>
<p>The mathematical trick, in a nutshell, is to use the Hankel transform to find a finite impulse response (FIR) filter that approximates the frequency-domain fractional-Laplacian operator, and apply that filter in the spatial domain via the efficient overlap-save algorithm. According to old Git commit logs, I first derived this technique in 2015.</p>
<p>Links:</p>
<ul>
<li>this mathematical–software document for reading: <a href="https://fasiha.github.io/texshade-py/">homepage</a></li>
<li>this code repository: on <a href="https://github.com/fasiha/texshade-py/">GitHub</a></li>
<li>this module: on <a href="https://pypi.org/project/texshade/">PyPI</a></li>
</ul>
<h2 id="installation-and-usage">Installation and usage</h2>
<p>To install this library:</p>
<pre><code>$ pip install texshade</code></pre>
<p>To use it, in your Python code:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">import</span> texshade</span></code></pre></div>
<p>The rest of this document provides examples on using the following two major functions exposed by this library. Their API is as follows.</p>
<h3 id="def-texshadefftx-npndarray-alpha-float---npndarray-fft-based-texture-shading-elevation"><code>def texshadeFFT(x: np.ndarray, alpha: float) -&gt; np.ndarray</code> FFT-based texture shading elevation</h3>
<p>Given an array <code>x</code> of elevation data and an <code>alpha</code> &gt; 0, apply the texture-shading algorithm using the full (real-only) FFT: the entire <code>x</code> array will be FFT'd.</p>
<p><code>alpha</code> is the shading detail factor, i.e., the power of the fractional-Laplacian operator. <code>alpha=0</code> means no detail (output is the input). <code>alpha=2.0</code> is the full (non-fractional) Laplacian operator and is probably too high. <code>alpha &lt;= 1.0</code> seem aesthetically pleasing.</p>
<p>Returns an array the same dimensions as <code>x</code> that contains the texture-shaded version of the input array.</p>
<p>If <code>x</code> is memory-mapped and/or your system doesn't have 5x <code>x</code>'s memory available, consider using <code>texshade.texshadeSpatial</code>, which implements a low-memory version of the algorithm by approximating the frequency response of the fractional-Laplacian filter with a finite impulse response filter applied in the spatial-domain.</p>
<p>Implementation note: this function uses Scipy's FFTPACK routines (in <code>scipy.fftpack</code>) instead of Numpy's FFT (<code>numpy.fft</code>) because the former can return single-precision float32. In newer versions of Numpy/Scipy, this advantage may have evaporated <a href="https://github.com/numpy/numpy/issues/6012">1</a>, <a href="https://github.com/scipy/scipy/issues/2487">2</a>.</p>
<h3 id="texshadespatial-low-memory-approximation-of-the-texture-shading-algorithm"><code>texshadeSpatial</code> Low-memory approximation of the texture shading algorithm</h3>
<p>Full signature:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">def</span> texshadeSpatial(</span>
<span id="cb3-2"><a href="#cb3-2"></a>    x: np.ndarray,</span>
<span id="cb3-3"><a href="#cb3-3"></a>    alpha: <span class="bu">float</span>,</span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="co"># halfHankel args</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    nDiameter: <span class="bu">int</span>,</span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="co"># halfHankel kwargs</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    interpMethod<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb3-8"><a href="#cb3-8"></a>    sampleSpacing<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb3-9"><a href="#cb3-9"></a>    hbTaps<span class="op">=</span><span class="dv">128</span>,</span>
<span id="cb3-10"><a href="#cb3-10"></a>    hbTransitionWidth<span class="op">=</span><span class="fl">0.03</span>,</span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="co"># ols kwargs</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    size<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb3-13"><a href="#cb3-13"></a>    nfft<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb3-14"><a href="#cb3-14"></a>    out<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb3-15"><a href="#cb3-15"></a>) <span class="op">-&gt;</span> np.ndarray:</span></code></pre></div>
<p>Unlike <code>texshade.texshadeFFT</code>, which computes an FFT of the entire input elevation array <code>x</code> and applies the fractional-Laplacian filter in the frequency domain, this function approximates that frequency response with a spatial-domain finite impulse response (FIR) filter that is applied in the spatial domain via fast-convolution (overlap-save method). This allows <code>x</code> to be memory-mapped and/or very large relative to the amount of free system memory.</p>
<p><code>alpha</code> is the shading detail factor, i.e., the power of the fractional-Laplacian operator. <code>alpha=0</code> means no detail (output is the input). <code>alpha=2.0</code> is the full (non-fractional) Laplacian operator and is probably too high. <code>alpha &lt;= 1.0</code> seem aesthetically pleasing.</p>
<p>Returns an array the same dimensions as <code>x</code> that contains the texture-shaded version of the input array.</p>
<p><code>nDiameter</code> specifies the size of the spatial-domain FIR filter to apply to <code>x</code>. It is in the same units as <code>x</code>. The larger this is, the closer the output will be to the return value of <code>texshade.texshadeFFT</code>. This number controls the size of the neighborhood around a given pixel that contribute to that pixel's final texture-shaded value. If this is too small, the output will differ significantly from the full texture shading algorithm. If it is too big, you may run out of memory, because the overlap-save algorithm for fast-convolution will compute FFTs <em>at least</em> this size.</p>
<p><strong>Spatial filter generation keyword args</strong> passed to <code>texshade.hankel.halfHankel</code>: see that function's docstring for details, but reasonable values are chosen for these:</p>
<ul>
<li><code>interpMethod</code></li>
<li><code>sampleSpacing</code></li>
<li><code>hbTaps</code></li>
<li><code>hbTransitionWidth</code></li>
</ul>
<p><strong>Overlap-save keyword args</strong> passed to <code>ols.ols</code> (this function is in the <code>overlap-save</code> module on PyPI):</p>
<ul>
<li><code>size</code></li>
<li><code>nfft</code></li>
<li><code>out</code></li>
</ul>
<p><code>size</code>, a 2-list, specifies the size of the sub-arrays of the texture-shaded output to compute in each overlap-save step, while <code>nfft</code> (also a 2-list) is the size of the zero-padded FFT that will be taken at each overlap-save FFT. The requirement is that <code>nfft &gt;= size + nDiameter - 1</code> for both dimensions. If <code>nfft</code> isn't provided, suitable numbers with small prime factors will be selected. If <code>size</code> isn't specified, a small multiple of <code>nDiameter</code> is chosen.</p>
<p>N.B. It is beneficial to make <code>size</code> as big as can fit in your system memory. Suppose <code>nDiameter</code> is 1000. If you make <code>size=[15*1024, 15*1024]</code>, overlap-save will pick <code>nfft=[16*1024, 16*1024]</code> or a bit smaller. A 16k by 16k array of float64 (actually, they'll be complex128, but the real-only FFT will only need half as much space, due to Fourier symmetry) uses 2 GB of memory. You'll probably need 4x this much to store all the intermediate FFT-related arrays:</p>
<ol>
<li>the FFT of the spatial filter,</li>
<li>the FFT of the roughly 16k by 16k chunk of input</li>
<li>the product of the two</li>
<li>the inverse-FFT of the product</li>
</ol>
<p>I assume your input pixels are int16 or float32, so much smaller before FFT than after. So if your system has 8 GB free, you could pick <code>size=[15*1024, 15*1024]</code>. A rough equation might be, if your system has <code>M</code> GB, let each element of <code>size</code> be roughly <code>np.sqrt(M / 4 * 1024**3 / 8) - nDiameter</code>.</p>
<p><code>out</code> allows you to specify the output array to store the results in. This is useful when you have a memory-mapped array prepared to accept the output of the algorithm, which will be float64. If <code>out.dtype</code> is not <code>float64</code>, then Numpy will perform a conversion, which might be expensive. If provided, this is returned. If not specified, a new array is allocated, filled, and returned.</p>
<h2 id="the-texture-shading-algorithm">The texture-shading algorithm</h2>
<blockquote>
<p>N.B. The following contains LaTeX-typeset mathematics. If you see gibberish instead of math, make sure you're reading this on <a href="https://fasiha.github.io/texshade-py">the repo website</a>, where KaTeX will format it (assuming you have JavaScript enabled). And in case you want it, here's the <a href="https://github.com/fasiha/texshade-py/">GitHub repo</a> itself.</p>
</blockquote>
<p>The original texture shading algorithm takes a 2D array of elevations, call it \(x\), and computes the texture-shaded elevation map,</p>
<p>$$y = F^{-1}[F[x] ⋅ |\vec f|^α],$$</p>
<p>where</p>
<ul>
<li>\(F[\cdot]\) is the 2D Fourier transform operator and \(F^{-1}[\cdot]\) its inverse</li>
<li>\(\vec f = [f_x, f_y]'\) the 2D vector of Fourier coordinates, so \(|\vec f|^α=(f_x^2 + f_y^2)^{α/2}\)</li>
<li>\(()'\) indicates matrix or vector transpose</li>
<li>\(0&lt;α≤1\), the "fraction" in the fractional-Laplacian (though Brown gives examples of \(α≤2\)!).</li>
</ul>
<p>While many details of the algorithm have yet to be specified, the output array \(y\) can be made to have the same size as the input \(x\).</p>
<p>Let's implement this in Python.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># export texshade/texshade.py</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="im">import</span> scipy.fftpack <span class="im">as</span> scifft</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="im">from</span> nextprod <span class="im">import</span> nextprod</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="kw">def</span> texshadeFFT(x: np.ndarray, alpha: <span class="bu">float</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb4-8"><a href="#cb4-8"></a>  <span class="co">&quot;&quot;&quot;FFT-based texture shading elevation</span></span>
<span id="cb4-9"><a href="#cb4-9"></a></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co">  Given an array `x` of elevation data and an `alpha` &gt; 0, apply the</span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co">  texture-shading algorithm using the full (real-only) FFT: the entire `x` array</span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co">  will be FFT&#39;d.</span></span>
<span id="cb4-13"><a href="#cb4-13"></a></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="co">  `alpha` is the shading detail factor, i.e., the power of the</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co">  fractional-Laplacian operator. `alpha=0` means no detail (output is the</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="co">  input). `alpha=2.0` is the full (non-fractional) Laplacian operator and is</span></span>
<span id="cb4-17"><a href="#cb4-17"></a><span class="co">  probably too high. `alpha &lt;= 1.0` seem aesthetically pleasing.</span></span>
<span id="cb4-18"><a href="#cb4-18"></a></span>
<span id="cb4-19"><a href="#cb4-19"></a><span class="co">  Returns an array the same dimensions as `x` that contains the texture-shaded</span></span>
<span id="cb4-20"><a href="#cb4-20"></a><span class="co">  version of the input array.</span></span>
<span id="cb4-21"><a href="#cb4-21"></a></span>
<span id="cb4-22"><a href="#cb4-22"></a><span class="co">  If `x` is memory-mapped and/or your system doesn&#39;t have 5x `x`&#39;s memory</span></span>
<span id="cb4-23"><a href="#cb4-23"></a><span class="co">  available, consider using `texshade.texshadeSpatial`, which implements a</span></span>
<span id="cb4-24"><a href="#cb4-24"></a><span class="co">  low-memory version of the algorithm by approximating the frequency response of</span></span>
<span id="cb4-25"><a href="#cb4-25"></a><span class="co">  the fractional-Laplacian filter with a finite impulse response filter applied</span></span>
<span id="cb4-26"><a href="#cb4-26"></a><span class="co">  in the spatial-domain.</span></span>
<span id="cb4-27"><a href="#cb4-27"></a></span>
<span id="cb4-28"><a href="#cb4-28"></a><span class="co">  Implementation note: this function uses Scipy&#39;s FFTPACK routines (in</span></span>
<span id="cb4-29"><a href="#cb4-29"></a><span class="co">  `scipy.fftpack`) instead of Numpy&#39;s FFT (`numpy.fft`) because the former can</span></span>
<span id="cb4-30"><a href="#cb4-30"></a><span class="co">  return single-precision float32. In newer versions of Numpy/Scipy, this</span></span>
<span id="cb4-31"><a href="#cb4-31"></a><span class="co">  advantage may have evaporated [1], [2].</span></span>
<span id="cb4-32"><a href="#cb4-32"></a></span>
<span id="cb4-33"><a href="#cb4-33"></a><span class="co">  [1] https://github.com/numpy/numpy/issues/6012</span></span>
<span id="cb4-34"><a href="#cb4-34"></a><span class="co">  [2] https://github.com/scipy/scipy/issues/2487</span></span>
<span id="cb4-35"><a href="#cb4-35"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb4-36"><a href="#cb4-36"></a>  Nyx <span class="op">=</span> [nextprod([<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>], x) <span class="cf">for</span> x <span class="kw">in</span> x.shape]</span>
<span id="cb4-37"><a href="#cb4-37"></a></span>
<span id="cb4-38"><a href="#cb4-38"></a>  <span class="co"># Generate filter in the frequency domain</span></span>
<span id="cb4-39"><a href="#cb4-39"></a>  fy <span class="op">=</span> scifft.rfftfreq(Nyx[<span class="dv">0</span>])[:, np.newaxis].astype(x.dtype)</span>
<span id="cb4-40"><a href="#cb4-40"></a>  fx <span class="op">=</span> scifft.rfftfreq(Nyx[<span class="dv">1</span>])[np.newaxis, :].astype(x.dtype)</span>
<span id="cb4-41"><a href="#cb4-41"></a>  H2 <span class="op">=</span> (fx<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> fy<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span>(alpha <span class="op">/</span> <span class="fl">2.0</span>)</span>
<span id="cb4-42"><a href="#cb4-42"></a></span>
<span id="cb4-43"><a href="#cb4-43"></a>  <span class="co"># Define forward and backwards transforms</span></span>
<span id="cb4-44"><a href="#cb4-44"></a>  rfft2 <span class="op">=</span> <span class="kw">lambda</span> x: scifft.rfft(scifft.rfft(x, Nyx[<span class="dv">1</span>], <span class="dv">1</span>, <span class="va">True</span>), Nyx[<span class="dv">0</span>], <span class="dv">0</span>, <span class="va">True</span>)</span>
<span id="cb4-45"><a href="#cb4-45"></a>  irfft2 <span class="op">=</span> <span class="kw">lambda</span> X: scifft.irfft(scifft.irfft(X, axis<span class="op">=</span><span class="dv">0</span>, overwrite_x<span class="op">=</span><span class="va">True</span>), overwrite_x<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-46"><a href="#cb4-46"></a></span>
<span id="cb4-47"><a href="#cb4-47"></a>  <span class="co"># Compute the FFT of the input and apply the filter</span></span>
<span id="cb4-48"><a href="#cb4-48"></a>  xr <span class="op">=</span> rfft2(x) <span class="op">*</span> H2</span>
<span id="cb4-49"><a href="#cb4-49"></a>  H2 <span class="op">=</span> <span class="va">None</span>  <span class="co"># potentially trigger GC here to reclaim H2&#39;s memory</span></span>
<span id="cb4-50"><a href="#cb4-50"></a>  xr <span class="op">=</span> irfft2(xr)</span>
<span id="cb4-51"><a href="#cb4-51"></a>  <span class="co"># Return the same size as input</span></span>
<span id="cb4-52"><a href="#cb4-52"></a>  <span class="cf">return</span> xr[:x.shape[<span class="dv">0</span>], :x.shape[<span class="dv">1</span>]]</span></code></pre></div>
<h2 id="test-setup">Test setup</h2>
<p>I've downloaded three tiles from the SRTM DEM (from <a href="https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/">this page at SDSC.edu</a>) on the African coastline near 0° N and 0° W and merged them into a single raster using <a href="https://gdal.org/">GDAL</a>, which I installed using <a href="https://formulae.brew.sh/formula/gdal">Brew</a>: installing these is outside the scope of this document, but any DEM you have can be used.</p>
<pre><code>wget https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/N00E009.hgt \
  https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/N00E010.hgt \
  https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/N00E011.hgt
gdalwarp -of GTiff N00E009.hgt N00E010.hgt N00E011.hgt merged.tif</code></pre>
<p>Running <code>gdalinfo merged.tif</code> produces the following output:</p>
<pre><code>Driver: GTiff/GeoTIFF
Files: merged.tif
Size is 10801, 3601
Coordinate System is:
GEOGCS[&quot;WGS 84&quot;,
    DATUM[&quot;WGS_1984&quot;,
        SPHEROID[&quot;WGS 84&quot;,6378137,298.257223563,
            AUTHORITY[&quot;EPSG&quot;,&quot;7030&quot;]],
        AUTHORITY[&quot;EPSG&quot;,&quot;6326&quot;]],
    PRIMEM[&quot;Greenwich&quot;,0],
    UNIT[&quot;degree&quot;,0.0174532925199433],
    AUTHORITY[&quot;EPSG&quot;,&quot;4326&quot;]]
Origin = (8.999861111111111,1.000138888888889)
Pixel Size = (0.000277777777778,-0.000277777777778)
Metadata:
  AREA_OR_POINT=Point
Image Structure Metadata:
  INTERLEAVE=BAND
Corner Coordinates:
Upper Left  (   8.9998611,   1.0001389) (  8d59&#39;59.50&quot;E,  1d 0&#39; 0.50&quot;N)
Lower Left  (   8.9998611,  -0.0001389) (  8d59&#39;59.50&quot;E,  0d 0&#39; 0.50&quot;S)
Upper Right (  12.0001389,   1.0001389) ( 12d 0&#39; 0.50&quot;E,  1d 0&#39; 0.50&quot;N)
Lower Right (  12.0001389,  -0.0001389) ( 12d 0&#39; 0.50&quot;E,  0d 0&#39; 0.50&quot;S)
Center      (  10.5000000,   0.5000000) ( 10d30&#39; 0.00&quot;E,  0d30&#39; 0.00&quot;N)
Band 1 Block=10801x1 Type=Int16, ColorInterp=Gray
  NoData Value=-32768
  Unit Type: m</code></pre>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># export convert.py</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co">Quick script intended to be used only by a user to convert a specific</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="co">GeoTIF to a NPY file for pure-Numpy non-GDAL demo.</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="im">import</span> gdal, gdalconst</span>
<span id="cb7-8"><a href="#cb7-8"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif&#39;</span></span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="kw">def</span> filenameToData(fname: <span class="bu">str</span>, dtype<span class="op">=</span>np.float32):</span>
<span id="cb7-12"><a href="#cb7-12"></a>  <span class="co">&quot;&quot;&quot;Reads all bands&quot;&quot;&quot;</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>  fileHandle <span class="op">=</span> gdal.Open(fname, gdalconst.GA_ReadOnly)</span>
<span id="cb7-14"><a href="#cb7-14"></a>  result <span class="op">=</span> np.squeeze(</span>
<span id="cb7-15"><a href="#cb7-15"></a>      np.dstack(</span>
<span id="cb7-16"><a href="#cb7-16"></a>          [fileHandle.GetRasterBand(n <span class="op">+</span> <span class="dv">1</span>).ReadAsArray() <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(fileHandle.RasterCount)]))</span>
<span id="cb7-17"><a href="#cb7-17"></a>  <span class="cf">if</span> dtype <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb7-18"><a href="#cb7-18"></a>    <span class="cf">return</span> result.astype(dtype)</span>
<span id="cb7-19"><a href="#cb7-19"></a>  <span class="cf">return</span> result</span>
<span id="cb7-20"><a href="#cb7-20"></a></span>
<span id="cb7-21"><a href="#cb7-21"></a></span>
<span id="cb7-22"><a href="#cb7-22"></a>np.save(fname, filenameToData(fname))</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># export demo.py</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="im">import</span> texshade</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-4"><a href="#cb8-4"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif.npy&#39;</span></span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a>arr <span class="op">=</span> np.load(fname)</span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="bu">print</span>(arr)</span>
<span id="cb8-8"><a href="#cb8-8"></a>tex <span class="op">=</span> texshade.texshadeFFT(arr, <span class="fl">0.8</span>)</span>
<span id="cb8-9"><a href="#cb8-9"></a>np.save(fname <span class="op">+</span> <span class="st">&#39;.tex&#39;</span>, tex)</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># export postprocess.py</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="kw">def</span> touint(x: np.ndarray, cmin, cmax, dtype<span class="op">=</span>np.uint8) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb9-6"><a href="#cb9-6"></a>  <span class="co">&quot;&quot;&quot;Convert an array to an array of unsigned integers by clamping and scaling</span></span>
<span id="cb9-7"><a href="#cb9-7"></a></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="co">  Given an array of numbers `x`, and the desired min and max values, `cmin` and</span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="co">  `cmax` respectively, and optionally a `dtype` that defaults to `uint8`, clamp</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="co">  the values of `x` to between `cmin` and `cmax` (i.e., if a pixel is less than</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="co">  `cmin`, it will be treated as being equal to `cmin`) and scale the values</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="co">  linearly to the full range supported by `dtype`. When `dtype` is `np.uint8`,</span></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="co">  e.g., the output will have values between 0 (originally `cmin`) and 255</span></span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="co">  (originally `cmax`).</span></span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>  <span class="co"># clamp x between cmin and cmax</span></span>
<span id="cb9-17"><a href="#cb9-17"></a>  x[x <span class="op">&lt;</span> cmin] <span class="op">=</span> cmin</span>
<span id="cb9-18"><a href="#cb9-18"></a>  x[x <span class="op">&gt;</span> cmax] <span class="op">=</span> cmax</span>
<span id="cb9-19"><a href="#cb9-19"></a>  <span class="co"># map [cmin, cmax] to [0, 2**depth-1-eps] linearly</span></span>
<span id="cb9-20"><a href="#cb9-20"></a>  maxval <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">8</span> <span class="op">*</span> dtype().itemsize) <span class="op">-</span> <span class="fl">1e-3</span></span>
<span id="cb9-21"><a href="#cb9-21"></a>  slope <span class="op">=</span> (maxval <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">/</span> (cmax <span class="op">-</span> cmin)</span>
<span id="cb9-22"><a href="#cb9-22"></a>  ret <span class="op">=</span> slope <span class="op">*</span> (x <span class="op">-</span> cmin) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb9-23"><a href="#cb9-23"></a>  <span class="cf">return</span> (ret).astype(dtype)</span>
<span id="cb9-24"><a href="#cb9-24"></a></span>
<span id="cb9-25"><a href="#cb9-25"></a></span>
<span id="cb9-26"><a href="#cb9-26"></a><span class="kw">def</span> toPng(scaled: np.ndarray, fname: <span class="bu">str</span>):</span>
<span id="cb9-27"><a href="#cb9-27"></a>  <span class="co">&quot;&quot;&quot;Write a uint8 array `scaled` to a PNG file `fname`&quot;&quot;&quot;</span></span>
<span id="cb9-28"><a href="#cb9-28"></a>  <span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb9-29"><a href="#cb9-29"></a>  newimage <span class="op">=</span> Image.new(<span class="st">&#39;L&#39;</span>, (scaled.shape[<span class="dv">1</span>], scaled.shape[<span class="dv">0</span>]))  <span class="co"># type, (width, height)</span></span>
<span id="cb9-30"><a href="#cb9-30"></a>  newimage.putdata(scaled.ravel())</span>
<span id="cb9-31"><a href="#cb9-31"></a>  newimage.save(fname)</span>
<span id="cb9-32"><a href="#cb9-32"></a></span>
<span id="cb9-33"><a href="#cb9-33"></a></span>
<span id="cb9-34"><a href="#cb9-34"></a><span class="kw">def</span> texToPng(tex: np.ndarray, fname: <span class="bu">str</span>, quantiles<span class="op">=</span><span class="va">None</span>, borderFractions<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb9-35"><a href="#cb9-35"></a>  <span class="co">&quot;&quot;&quot;Quantile a texture-shaded array and write it to 8-bit PNG</span></span>
<span id="cb9-36"><a href="#cb9-36"></a></span>
<span id="cb9-37"><a href="#cb9-37"></a><span class="co">  Given `tex`, a 2D array, and a `fname` path to a PNG file, and optionally a</span></span>
<span id="cb9-38"><a href="#cb9-38"></a><span class="co">  2-list `quantiles` (defaults to [0.01, 0.99], i.e., 1% and 99%), clamp the</span></span>
<span id="cb9-39"><a href="#cb9-39"></a><span class="co">  array to the quantile-values and write to a PNG. If `borderFractions`, also a</span></span>
<span id="cb9-40"><a href="#cb9-40"></a><span class="co">  2-list, is given, </span></span>
<span id="cb9-41"><a href="#cb9-41"></a></span>
<span id="cb9-42"><a href="#cb9-42"></a><span class="co">  `[np.round(total * frac) for total, frac in zip(tex.shape, borderFractions)]`</span></span>
<span id="cb9-43"><a href="#cb9-43"></a><span class="co">  </span></span>
<span id="cb9-44"><a href="#cb9-44"></a><span class="co">  pixels on either side of the border in each dimension are ignored in</span></span>
<span id="cb9-45"><a href="#cb9-45"></a><span class="co">  computing the quantiles.</span></span>
<span id="cb9-46"><a href="#cb9-46"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb9-47"><a href="#cb9-47"></a>  <span class="cf">if</span> quantiles <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-48"><a href="#cb9-48"></a>    quantiles <span class="op">=</span> [<span class="fl">0.01</span>, <span class="fl">0.99</span>]</span>
<span id="cb9-49"><a href="#cb9-49"></a>  <span class="cf">assert</span> <span class="bu">all</span>([x <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> x <span class="op">&lt;=</span> <span class="dv">1</span> <span class="cf">for</span> x <span class="kw">in</span> quantiles])</span>
<span id="cb9-50"><a href="#cb9-50"></a>  <span class="cf">if</span> borderFractions <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-51"><a href="#cb9-51"></a>    minmax <span class="op">=</span> np.quantile(tex.ravel(), quantiles)</span>
<span id="cb9-52"><a href="#cb9-52"></a>  <span class="cf">else</span>:</span>
<span id="cb9-53"><a href="#cb9-53"></a>    <span class="cf">assert</span> <span class="bu">all</span>([x <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> x <span class="op">&lt;</span> <span class="dv">1</span> <span class="cf">for</span> x <span class="kw">in</span> borderFractions])</span>
<span id="cb9-54"><a href="#cb9-54"></a>    border <span class="op">=</span> [<span class="bu">int</span>(np.<span class="bu">round</span>(total <span class="op">*</span> frac)) <span class="cf">for</span> total, frac <span class="kw">in</span> <span class="bu">zip</span>(tex.shape, borderFractions)]</span>
<span id="cb9-55"><a href="#cb9-55"></a>    slices <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">slice</span>(p, <span class="op">-</span>p <span class="cf">if</span> p <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>) <span class="cf">for</span> p <span class="kw">in</span> border)</span>
<span id="cb9-56"><a href="#cb9-56"></a>    minmax <span class="op">=</span> np.quantile(tex[slices].ravel(), quantiles)</span>
<span id="cb9-57"><a href="#cb9-57"></a></span>
<span id="cb9-58"><a href="#cb9-58"></a>  scaled <span class="op">=</span> touint(tex, minmax[<span class="dv">0</span>], minmax[<span class="dv">1</span>], np.uint8)</span>
<span id="cb9-59"><a href="#cb9-59"></a>  toPng(scaled, fname)</span>
<span id="cb9-60"><a href="#cb9-60"></a></span>
<span id="cb9-61"><a href="#cb9-61"></a></span>
<span id="cb9-62"><a href="#cb9-62"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</span>
<span id="cb9-63"><a href="#cb9-63"></a>  arr <span class="op">=</span> np.load(<span class="st">&#39;merged.tif.npy&#39;</span>)</span>
<span id="cb9-64"><a href="#cb9-64"></a>  tex <span class="op">=</span> np.load(<span class="st">&#39;merged.tif.npy.tex.npy&#39;</span>)</span>
<span id="cb9-65"><a href="#cb9-65"></a>  texToPng(tex, <span class="st">&#39;scaled.png&#39;</span>, quantiles<span class="op">=</span>[.<span class="dv">01</span>, <span class="fl">.99</span>], borderFractions<span class="op">=</span>[<span class="fl">1e-2</span>, <span class="fl">1e-2</span>])</span>
<span id="cb9-66"><a href="#cb9-66"></a>  toPng(touint(arr, np.<span class="bu">min</span>(arr), np.<span class="bu">max</span>(arr), np.uint8), <span class="st">&#39;orig.png&#39;</span>)</span></code></pre></div>
<pre><code>for i in orig.png scaled.png; do convert -filter Mitchell -sampling-factor 1x1 -quality 90 -resize 2048 $i $i.small.png; done</code></pre>
<h3 id="original">Original</h3>
<p><img src="orig.png.small.png" alt="original downsampled" /></p>
<h3 id="tex-shaded">Tex-shaded</h3>
<p><img src="scaled.png.small.png" alt="tex-shaded downsampled" /></p>
<h2 id="the-approximation">The approximation</h2>
<p>Is there any way to apply the fractional-Laplacian operator, which is expressed in the frequency-domain as \(|\vec f|^α ⋅ F[x]\) for an input array \(x\), that <em>doesn't</em> require a 2D Fourier transform of \(x\)? Recall that the Fourier transform is a unitary operator—that is, \(F[x]\) can be seen as a matrix–vector product \(\underline F ⋅ \underline x\), where the underlines represent a matrix or vector version of the operator or its input, and \(\underline F\) is a unitary matrix (the complex-domain extension of an orthogonal matrix). This indicates that each element of the output of a Fourier transform is a function of each of the input elements (though because it can do this in \(log(N)\) operations, instead of \(N\), we call it the <em>fast</em> Fourier transform (FFT)). There doesn't seem to be a memory-local way to convert the array of elevations to the Fourier domain, since each frequency bin has contributions from each pixel in the elevation array.</p>
<p>But we do know from linear systems theory that multiplication in the frequency domain is equivalent to convolution in the spatial domain. We can ask if there's any structure to the spatial-domain representation of the fractional-Laplacian \(|\vec f|^α\), i.e., what is \(F^{-1}[|\vec f|^α]\)?</p>
<p>Trawling through the Wikipedia I stumbled on <a href="https://en.wikipedia.org/w/index.php?title=Hankel_transform&amp;oldid=901300195#Relation_to_the_Fourier_transform_(circularly_symmetric_case)">the Hankel transform and its relationship to the Fourier transform of circularly-symmetric functions</a>. Wikipedia notes that for a two-dimensional radial function \(f(r)\), its two-dimensional Fourier transform \(F(\vec k)\) is</p>
<p>$$F(\vec k) = F(k) = 2π\int_0^{\infty} f(r) ⋅ J_0(k r) \cdot r ⋅ dr,$$ where \(J_0(⋅)\) is the Bessel function of the first kind of order 0. In our notation, if we represent the fractional-Laplacian operator as \(l(\vec f) = l(f) = f^α\) ("l" for "Laplacian"), its Fourier transform is, according to <a href="https://www.wolframalpha.com/input/?i=2*pi*Integrate%5Bf%5Ea+*+BesselJ%5B0%2C+k+*+f%5D+*+f%2C+f%2C+0%2C+m%5D">Wolfram Alpha</a>,</p>
<p>$$2π\int_0^m f ⋅ f^α J_0(f r) df = 2π \frac{m^{α + 2}}{α + 2} \cdot {}_{1}F_2([α / 2 + 1], [1, α / 2 + 2], -(r ⋅ m / 2)^2)$$ where</p>
<ul>
<li>\(r\) is my variable for the radius in the spatial domain,</li>
<li>\(1F2\) is a generalized hypergeometric function (not "the" hypergeometric function \(2F1\)!), and</li>
<li>where I left the upper limit of the integral as \(m\) (for "max") because we have a bound on the extent of the frequency domain \(\vec f = [f_x, f_y]'\), since \(-π ≤ f_x &lt; π\) radians per pixel, and same for \(f_y\). (Recall this happens because we are working with a discrete-valued array of elevations \(x\), so the Fourier transform is a discrete-time Fourier transform (DTFT) and is periodic every 2π radians per pixel.)</li>
</ul>
<blockquote>
<p>Odd sidebar. My little knowledge of mathematics is exhausted by wondering why, if I omit the 2π in the expression to Wolfram Alpha, it returns a much more complicated expression including Γ functions. Sympy similar story.</p>
</blockquote>
<p>The constant factors that accrete when working with Fourier transform pairs are usually incredibly tedious to keep track of, especially when evaluating them with the FFT. My normal practice is to get things working up to a constant factor and then see if I need to worry about that factor.</p>
<p>So let us ask what the Fourier transform of an array containing evaluations of the radial function</p>
<p>$$L(r) = {}_{1}F_2([α / 2 + 1], [1, α / 2 + 2], -(r ⋅ π / 2)^2).$$ We use the maximum of the integral in the Hankel transform is \(m=π\). Recall we use "l" and "L" for "Laplacian": \(L(r)\) is the Fourier transform of the fractional-Laplacian \(l(f) = |f|^α\).</p>
<p>We do this in the code snippet below: we evaluate the above generalized hypergeometric function on a 200×200 array of radii. We assume the array's horizontal and vertical axes run from -100 to 99, i.e., assuming one pixel spacing for each element, compute each element's radius \(r\), and evaluate \(L(r)\). Then we look at its 2D FFT, which will be all-real because the input is symmetric. (Recall that in general, the Fourier transform of a real vector will contain complex entries but be conjugate-symmetric about the origin. The Fourier transform will contain zero imaginary components only if its input was symmetric about the origin.)</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># export math-hankel.py</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="im">from</span> mpmath <span class="im">import</span> hyper</span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="im">import</span> numpy.fft <span class="im">as</span> fft</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="im">import</span> pylab <span class="im">as</span> plt</span>
<span id="cb11-6"><a href="#cb11-6"></a>plt.style.use(<span class="st">&#39;ggplot&#39;</span>)</span>
<span id="cb11-7"><a href="#cb11-7"></a></span>
<span id="cb11-8"><a href="#cb11-8"></a></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="kw">def</span> spatial(r, a):</span>
<span id="cb11-10"><a href="#cb11-10"></a>  <span class="co">&quot;Evaluate L(r), proportional to the Fourier transform of |f|**α&quot;</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>  <span class="cf">return</span> <span class="bu">float</span>(hyper((<span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">1</span>,), (<span class="fl">1.0</span>, <span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">2</span>), <span class="fl">-0.25</span> <span class="op">*</span> (r <span class="op">*</span> np.pi)<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb11-12"><a href="#cb11-12"></a></span>
<span id="cb11-13"><a href="#cb11-13"></a></span>
<span id="cb11-14"><a href="#cb11-14"></a>xmat, ymat <span class="op">=</span> np.meshgrid(np.arange(<span class="op">-</span><span class="dv">100</span>, <span class="dv">100</span>), np.arange(<span class="op">-</span><span class="dv">100</span>, <span class="dv">100</span>))</span>
<span id="cb11-15"><a href="#cb11-15"></a>rmat <span class="op">=</span> np.sqrt(xmat<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ymat<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb11-16"><a href="#cb11-16"></a>alpha <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb11-17"><a href="#cb11-17"></a>h <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> r: spatial(r, alpha))(rmat)</span></code></pre></div>
<p>Above we use the fabulous <a href="http://mpmath.org/"><code>mpmath</code></a> package—a pure-Python arbitrary-precision package with extensive support for special functions, quadrature integration, linear algebra, etc., started by Fredrik Johansson in 2007 (when he was a teenager)—to compute the generalized hypergeometric function. Next, we'd like to visualize its Fourier transform—hopefully we see something that looks like \(|f|^{0.8}\).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># export math-hankel.py</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="kw">def</span> F2cent(arr):</span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="co">&quot;&quot;&quot;Origin-centered 2D Fourier transform&quot;&quot;&quot;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>  <span class="cf">return</span> fft.fftshift(fft.fft2(fft.ifftshift(arr)))</span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="kw">def</span> plotF2cent(arr):</span>
<span id="cb12-8"><a href="#cb12-8"></a>  <span class="co">&quot;&quot;&quot;Given an origin-centered 2D array, plot its 2D Fourier transform&quot;&quot;&quot;</span></span>
<span id="cb12-9"><a href="#cb12-9"></a></span>
<span id="cb12-10"><a href="#cb12-10"></a>  <span class="kw">def</span> extents(f):</span>
<span id="cb12-11"><a href="#cb12-11"></a>    delta <span class="op">=</span> f[<span class="dv">1</span>] <span class="op">-</span> f[<span class="dv">0</span>]</span>
<span id="cb12-12"><a href="#cb12-12"></a>    <span class="cf">return</span> [f[<span class="dv">0</span>] <span class="op">-</span> delta <span class="op">/</span> <span class="dv">2</span>, f[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> delta <span class="op">/</span> <span class="dv">2</span>]</span>
<span id="cb12-13"><a href="#cb12-13"></a></span>
<span id="cb12-14"><a href="#cb12-14"></a>  h, w <span class="op">=</span> arr.shape</span>
<span id="cb12-15"><a href="#cb12-15"></a>  x <span class="op">=</span> np.ceil(np.arange(w) <span class="op">-</span> w <span class="op">/</span> <span class="dv">2</span>) <span class="op">/</span> w</span>
<span id="cb12-16"><a href="#cb12-16"></a>  y <span class="op">=</span> np.ceil(np.arange(h) <span class="op">-</span> h <span class="op">/</span> <span class="dv">2</span>) <span class="op">/</span> h</span>
<span id="cb12-17"><a href="#cb12-17"></a>  fig, (sax, fax) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb12-18"><a href="#cb12-18"></a></span>
<span id="cb12-19"><a href="#cb12-19"></a>  sax.imshow(</span>
<span id="cb12-20"><a href="#cb12-20"></a>      arr,</span>
<span id="cb12-21"><a href="#cb12-21"></a>      aspect<span class="op">=</span><span class="st">&#39;equal&#39;</span>,</span>
<span id="cb12-22"><a href="#cb12-22"></a>      interpolation<span class="op">=</span><span class="st">&#39;none&#39;</span>,</span>
<span id="cb12-23"><a href="#cb12-23"></a>      extent<span class="op">=</span>extents(x <span class="op">*</span> w) <span class="op">+</span> extents(y <span class="op">*</span> h),</span>
<span id="cb12-24"><a href="#cb12-24"></a>      origin<span class="op">=</span><span class="st">&#39;lower&#39;</span>)</span>
<span id="cb12-25"><a href="#cb12-25"></a></span>
<span id="cb12-26"><a href="#cb12-26"></a>  fax.imshow(</span>
<span id="cb12-27"><a href="#cb12-27"></a>      np.real(F2cent(arr)),</span>
<span id="cb12-28"><a href="#cb12-28"></a>      aspect<span class="op">=</span><span class="st">&#39;equal&#39;</span>,</span>
<span id="cb12-29"><a href="#cb12-29"></a>      interpolation<span class="op">=</span><span class="st">&#39;none&#39;</span>,</span>
<span id="cb12-30"><a href="#cb12-30"></a>      extent<span class="op">=</span>extents(x) <span class="op">+</span> extents(y),</span>
<span id="cb12-31"><a href="#cb12-31"></a>      origin<span class="op">=</span><span class="st">&#39;lower&#39;</span>)</span>
<span id="cb12-32"><a href="#cb12-32"></a>  sax.grid(<span class="va">False</span>)</span>
<span id="cb12-33"><a href="#cb12-33"></a>  fax.grid(<span class="va">False</span>)</span>
<span id="cb12-34"><a href="#cb12-34"></a>  sax.set_xlabel(<span class="st">&#39;pixel&#39;</span>)</span>
<span id="cb12-35"><a href="#cb12-35"></a>  fax.set_xlabel(<span class="st">&#39;cycles/pixel&#39;</span>)</span>
<span id="cb12-36"><a href="#cb12-36"></a></span>
<span id="cb12-37"><a href="#cb12-37"></a>  <span class="cf">return</span> fig, sax, fax</span>
<span id="cb12-38"><a href="#cb12-38"></a></span>
<span id="cb12-39"><a href="#cb12-39"></a></span>
<span id="cb12-40"><a href="#cb12-40"></a>hplots <span class="op">=</span> plotF2cent(h)</span>
<span id="cb12-41"><a href="#cb12-41"></a>hplots[<span class="dv">1</span>].set_title(<span class="st">&#39;L(r): spatial-domain&#39;</span>)</span>
<span id="cb12-42"><a href="#cb12-42"></a>hplots[<span class="dv">2</span>].set_title(<span class="st">&#39;F[L(r)]: frequency-domain&#39;</span>)</span>
<span id="cb12-43"><a href="#cb12-43"></a>plt.savefig(<span class="st">&#39;full-hankel.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb12-44"><a href="#cb12-44"></a>plt.savefig(<span class="st">&#39;full-hankel.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb12-45"><a href="#cb12-45"></a></span>
<span id="cb12-46"><a href="#cb12-46"></a>actual <span class="op">=</span> np.real(F2cent(h))[<span class="dv">100</span>, :]</span>
<span id="cb12-47"><a href="#cb12-47"></a>f <span class="op">=</span> np.ceil(np.arange(<span class="dv">200</span>) <span class="op">-</span> <span class="dv">200</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">/</span> <span class="dv">200</span></span>
<span id="cb12-48"><a href="#cb12-48"></a>expected <span class="op">=</span> np.<span class="bu">abs</span>(f <span class="op">*</span> <span class="dv">4</span>)<span class="op">**</span>alpha</span>
<span id="cb12-49"><a href="#cb12-49"></a>plt.figure()</span>
<span id="cb12-50"><a href="#cb12-50"></a>plt.plot(f, actual, <span class="st">&#39;-&#39;</span>, f, expected, <span class="st">&#39;--&#39;</span>, f, actual <span class="op">/</span> expected, <span class="st">&#39;.&#39;</span>)</span>
<span id="cb12-51"><a href="#cb12-51"></a>plt.xlabel(<span class="st">&#39;f (cycles/pixel)&#39;</span>)</span>
<span id="cb12-52"><a href="#cb12-52"></a>plt.legend([<span class="st">&#39;actual&#39;</span>, <span class="st">&#39;expected&#39;</span>, <span class="st">&#39;actual/expected&#39;</span>])</span>
<span id="cb12-53"><a href="#cb12-53"></a>plt.title(<span class="st">&#39;Cut of actual F[L(r)] versus expected |4⋅f|^0.8&#39;</span>)</span>
<span id="cb12-54"><a href="#cb12-54"></a>plt.savefig(<span class="st">&#39;full-hankel-actual-expected.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb12-55"><a href="#cb12-55"></a>plt.savefig(<span class="st">&#39;full-hankel-actual-expected.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span></code></pre></div>
<p><img src="full-hankel.png" alt="An array of evaluating the expression we computed for the Fourier transform of the fractional-Laplacian operator, and it&#39;s actual Fourier transform" /></p>
<p>Above: an array of evaluating the expression we computed for the Fourier transform of the fractional-Laplacian operator, and it's actual Fourier transform.</p>
<p><img src="full-hankel-actual-expected.svg" alt="Comparing the actual frequency response of our expression for the spatial-domain equivalent of the fractional-Laplacial, versus the expected frequency response, and their difference, which is approximately 1.024" /></p>
<p>Above: Comparing the actual frequency response of our expression for the spatial-domain equivalent of the fractional-Laplacial, versus the expected frequency response, and their difference, which is approximately 1.024.</p>
<p>This is a success! First, note that the 200×200 array on the left is close to zero: it has a bright center, and decays quickly as the radius from the center–origin grows. Next, note that its 2D Fourier transform is indeed what we had hoped: it sweeps out \(∝|f|^{α=0.8}\) radially, for angular radii between 0 and π radians (normalized here to cycles instead of radians: the axes between ±0.5 cycles per pixel correspond to ±π radians per pixel). (The symbol "\(∝\)" is read as "proportional to".)</p>
<p>The second plot above shows the near-constant ratio between the center-cut through the FFT of the spatial filter \(L(r)\) and a scaled version of what we expect. Comparing \(|4f|^α\), for \(α=0.8\), to the cut through the FFT's output, we see a very-nearly-constant ratio of 1.024. Do note that the actual value inside the absolute value is irrelevant, and amounts only to scaling the texture-shaded output.</p>
<p><strong>However</strong>, we cannot use \(L(r)\) as a spatial-domain equivalent of texture shading because recall that the original algorithm requires</p>
<p>$$y = F^{-1}[F[x] ⋅ |\vec f|^α],$$ but \(|\vec f|^α\) includes the <em>corners</em> of the frequency domain, not the radial pattern we see from the circular bull's-eye chart above, where the corners in the frequency domain get zero weight. We might use \(L(r)\) nonetheless and accept the infidelity to the texture shading algorithm, but we don't need to. If we decimate the spatial-domain filter \(L(r)\) by two, then we effectively get the middle-half of its frequency response, which will be \(∝|f|^α\) all the way out to its edges. The Scipy ecosystem provides several ways to <a href="https://docs.scipy.org/doc/scipy/reference/signal.html#filter-design">design halfband filters</a>. A simple example to demonstrate the idea will suffice: design an 8th order low-pass Butterworth filter and apply it along rows and columns of the spatial-domain filter, then downsample the result (throw away every other row/column):</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># export math-hankel.py</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="im">import</span> scipy.signal <span class="im">as</span> sig</span>
<span id="cb13-3"><a href="#cb13-3"></a>lpf <span class="op">=</span> sig.iirfilter(<span class="dv">8</span>, <span class="fl">0.5</span>, btype<span class="op">=</span><span class="st">&#39;lowpass&#39;</span>, ftype<span class="op">=</span><span class="st">&#39;butter&#39;</span>)</span>
<span id="cb13-4"><a href="#cb13-4"></a>hiir <span class="op">=</span> sig.filtfilt(<span class="op">*</span>lpf, sig.filtfilt(<span class="op">*</span>lpf, h, axis<span class="op">=</span><span class="dv">0</span>), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a>lpfplots <span class="op">=</span> plotF2cent(hiir)</span>
<span id="cb13-7"><a href="#cb13-7"></a>decplots <span class="op">=</span> plotF2cent(hiir[:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>, :<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>])</span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a>lpfplots[<span class="dv">1</span>].set_title(<span class="st">&#39;LPF[L(r)]&#39;</span>)</span>
<span id="cb13-10"><a href="#cb13-10"></a>lpfplots[<span class="dv">2</span>].set_title(<span class="st">&#39;F[LPF[L(r)]]&#39;</span>)</span>
<span id="cb13-11"><a href="#cb13-11"></a>lpfplots[<span class="dv">0</span>].savefig(<span class="st">&#39;lpf-hankel.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb13-12"><a href="#cb13-12"></a>lpfplots[<span class="dv">0</span>].savefig(<span class="st">&#39;lpf-hankel.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb13-13"><a href="#cb13-13"></a></span>
<span id="cb13-14"><a href="#cb13-14"></a>decplots[<span class="dv">1</span>].set_title(<span class="st">&#39;HB[L(r)]&#39;</span>)</span>
<span id="cb13-15"><a href="#cb13-15"></a>decplots[<span class="dv">2</span>].set_title(<span class="st">&#39;F[HB[L(r)]]&#39;</span>)</span>
<span id="cb13-16"><a href="#cb13-16"></a>decplots[<span class="dv">0</span>].savefig(<span class="st">&#39;hb-hankel.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb13-17"><a href="#cb13-17"></a>decplots[<span class="dv">0</span>].savefig(<span class="st">&#39;hb-hankel.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span></code></pre></div>
<p>The results are positive: while this filtering process can certainly be improved, we have obtained a spatial-domain filter that closely-approximates the fractional-Laplacian frequency-domain operator needed by the texture shading algorithm.</p>
<p><img src="lpf-hankel.png" alt="Low-pass-filtered version of our initial spatial-domain-created filter" /></p>
<p>Above: low-pass-filtered version of our initial spatial-domain-created filter.</p>
<p><img src="hb-hankel.png" alt="Halfbanded (decimated) version of our initial spatial-dmain-created filter: this meets the requirements of the original texture shading algorithm" /></p>
<p>Above: halfbanded (decimated) version of our initial spatial-dmain-created filter: this meets the requirements of the original texture shading algorithm.</p>
<h2 id="a-more-complete-implementation-of-the-approximation">A more complete implementation of the approximation</h2>
<div class="sourceCode" id="cb14"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="co"># export texshade/hankel.py</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="im">from</span> mpmath <span class="im">import</span> hyper</span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="im">from</span> scipy <span class="im">import</span> signal</span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="im">from</span> scipy.signal <span class="im">import</span> convolve2d</span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="im">import</span> numpy.fft <span class="im">as</span> fft</span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="im">import</span> functools</span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> interp1d</span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="im">from</span> typing <span class="im">import</span> Dict</span>
<span id="cb14-10"><a href="#cb14-10"></a></span>
<span id="cb14-11"><a href="#cb14-11"></a></span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="at">@functools.lru_cache</span>(maxsize<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="kw">def</span> spatial(r: <span class="bu">float</span>, a: <span class="bu">float</span>, integralMax<span class="op">=</span>np.pi) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb14-14"><a href="#cb14-14"></a>  <span class="co">&quot;Evaluate L(r), proportional to the Fourier transform of |f|**α&quot;</span></span>
<span id="cb14-15"><a href="#cb14-15"></a>  <span class="co"># Wolfram Alpha: `2*pi*Integrate[f^a * BesselJ[0, k * f] * f, f, 0, m]`</span></span>
<span id="cb14-16"><a href="#cb14-16"></a>  <span class="cf">return</span> <span class="bu">float</span>(hyper((<span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">1</span>,), (<span class="fl">1.0</span>, <span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">2</span>), <span class="fl">-0.25</span> <span class="op">*</span> (r <span class="op">*</span> integralMax)<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb14-17"><a href="#cb14-17"></a></span>
<span id="cb14-18"><a href="#cb14-18"></a></span>
<span id="cb14-19"><a href="#cb14-19"></a><span class="kw">def</span> vec(v: np.ndarray) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb14-20"><a href="#cb14-20"></a>  <span class="co">&quot;Convert a Numpy array to a column vector&quot;</span></span>
<span id="cb14-21"><a href="#cb14-21"></a>  <span class="cf">return</span> v.reshape(v.size, <span class="dv">-1</span>)</span>
<span id="cb14-22"><a href="#cb14-22"></a></span>
<span id="cb14-23"><a href="#cb14-23"></a></span>
<span id="cb14-24"><a href="#cb14-24"></a><span class="kw">def</span> fullHankel(n: <span class="bu">int</span>, alpha: <span class="bu">float</span>, interpMethod<span class="op">=</span><span class="va">True</span>, sampleSpacing<span class="op">=</span><span class="va">None</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb14-25"><a href="#cb14-25"></a>  <span class="co">&quot;&quot;&quot;Build a FIR filter approximating the fractional-Laplacian operator in the</span></span>
<span id="cb14-26"><a href="#cb14-26"></a><span class="co">  middle of its frequency response (non-ideal)</span></span>
<span id="cb14-27"><a href="#cb14-27"></a></span>
<span id="cb14-28"><a href="#cb14-28"></a><span class="co">  The returned array will be an `2 * n` by `2 * n` array. `alpha` is the scale</span></span>
<span id="cb14-29"><a href="#cb14-29"></a><span class="co">  fraction parameter that governs the amount of sharpening done by the</span></span>
<span id="cb14-30"><a href="#cb14-30"></a><span class="co">  fractional-Laplacian operator.</span></span>
<span id="cb14-31"><a href="#cb14-31"></a></span>
<span id="cb14-32"><a href="#cb14-32"></a><span class="co">  If `interpMethod=True`, then the values in the filter are</span></span>
<span id="cb14-33"><a href="#cb14-33"></a><span class="co">  linearly-interpolated from a grid of samples of the true function (via Hankel</span></span>
<span id="cb14-34"><a href="#cb14-34"></a><span class="co">  transform, implemented in `hankel.spatial`), sampled every `sampleSpacing`</span></span>
<span id="cb14-35"><a href="#cb14-35"></a><span class="co">  pixels. By default this is the case, and `sampleSpacing` is set to 1e-2</span></span>
<span id="cb14-36"><a href="#cb14-36"></a><span class="co">  pixels. This grid is saved to disk.</span></span>
<span id="cb14-37"><a href="#cb14-37"></a></span>
<span id="cb14-38"><a href="#cb14-38"></a><span class="co">  If `interpMethod=False`, then each pixel in the output array is exactly</span></span>
<span id="cb14-39"><a href="#cb14-39"></a><span class="co">  calculated via `hankel.spatial`. This might be much slower.</span></span>
<span id="cb14-40"><a href="#cb14-40"></a></span>
<span id="cb14-41"><a href="#cb14-41"></a><span class="co">  The returned array has a Fourier transform of $|f|^α$ where $|f| &lt; π$ radians</span></span>
<span id="cb14-42"><a href="#cb14-42"></a><span class="co">  per sample, and zero otherwise: that is, a circle inscribed in the unit square</span></span>
<span id="cb14-43"><a href="#cb14-43"></a><span class="co">  that contains the fractal response surrounded by zeros to the corners. This</span></span>
<span id="cb14-44"><a href="#cb14-44"></a><span class="co">  isn&#39;t exactly the same as the fractional-Laplacian operator, which is $|f|^α$</span></span>
<span id="cb14-45"><a href="#cb14-45"></a><span class="co">  for all $|f|$, even out to the corners.</span></span>
<span id="cb14-46"><a href="#cb14-46"></a></span>
<span id="cb14-47"><a href="#cb14-47"></a><span class="co">  See `hankel.halfHankel` for the fully-approximating version of this.</span></span>
<span id="cb14-48"><a href="#cb14-48"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb14-49"><a href="#cb14-49"></a>  rvec <span class="op">=</span> np.arange(<span class="op">-</span>n, n)</span>
<span id="cb14-50"><a href="#cb14-50"></a>  rmat <span class="op">=</span> np.sqrt(vec(rvec)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> vec(rvec).T<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb14-51"><a href="#cb14-51"></a></span>
<span id="cb14-52"><a href="#cb14-52"></a>  <span class="cf">if</span> interpMethod:</span>
<span id="cb14-53"><a href="#cb14-53"></a>    <span class="cf">if</span> <span class="kw">not</span> sampleSpacing:</span>
<span id="cb14-54"><a href="#cb14-54"></a>      sampleSpacing <span class="op">=</span> <span class="fl">1e-2</span></span>
<span id="cb14-55"><a href="#cb14-55"></a>    data <span class="op">=</span> precomputeLoad(alpha, np.ceil(np.sqrt(<span class="dv">2</span>) <span class="op">*</span> n <span class="op">*</span> <span class="fl">1.01</span>), sampleSpacing)</span>
<span id="cb14-56"><a href="#cb14-56"></a>    oned <span class="op">=</span> interp1d(data[<span class="st">&#39;r&#39;</span>], data[<span class="st">&#39;h&#39;</span>])</span>
<span id="cb14-57"><a href="#cb14-57"></a>    hmat <span class="op">=</span> oned(rmat)</span>
<span id="cb14-58"><a href="#cb14-58"></a>  <span class="cf">else</span>:</span>
<span id="cb14-59"><a href="#cb14-59"></a>    fun <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x: spatial(x, alpha))</span>
<span id="cb14-60"><a href="#cb14-60"></a>    hmat <span class="op">=</span> fun(rmat)</span>
<span id="cb14-61"><a href="#cb14-61"></a>  <span class="cf">return</span> hmat</span>
<span id="cb14-62"><a href="#cb14-62"></a></span>
<span id="cb14-63"><a href="#cb14-63"></a></span>
<span id="cb14-64"><a href="#cb14-64"></a><span class="kw">def</span> designHalfband(N: <span class="bu">int</span>, transitionWidth: <span class="bu">float</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb14-65"><a href="#cb14-65"></a>  <span class="co">&quot;&quot;&quot;Use the Remez exchange to design a halfband low-pass filter</span></span>
<span id="cb14-66"><a href="#cb14-66"></a></span>
<span id="cb14-67"><a href="#cb14-67"></a><span class="co">  `N` taps, with `transitionWidth &lt; 0.5` governing the transition band.</span></span>
<span id="cb14-68"><a href="#cb14-68"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb14-69"><a href="#cb14-69"></a>  <span class="cf">if</span> N <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb14-70"><a href="#cb14-70"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;N must be even&#39;</span>)</span>
<span id="cb14-71"><a href="#cb14-71"></a>  <span class="cf">if</span> N <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb14-72"><a href="#cb14-72"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;N must be &gt; 1&#39;</span>)</span>
<span id="cb14-73"><a href="#cb14-73"></a>  <span class="cf">if</span> <span class="kw">not</span> (transitionWidth <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> transitionWidth <span class="op">&lt;</span> <span class="fl">0.5</span>):</span>
<span id="cb14-74"><a href="#cb14-74"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;Need 0 &lt; transitionWidth &lt; 0.5&#39;</span>)</span>
<span id="cb14-75"><a href="#cb14-75"></a>  bands <span class="op">=</span> np.array([<span class="fl">0.</span>, <span class="fl">.25</span> <span class="op">-</span> transitionWidth, <span class="fl">.25</span> <span class="op">+</span> transitionWidth, <span class="fl">.5</span>])</span>
<span id="cb14-76"><a href="#cb14-76"></a>  h <span class="op">=</span> signal.remez(N <span class="op">+</span> <span class="dv">1</span>, bands, [<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">1</span>])</span>
<span id="cb14-77"><a href="#cb14-77"></a>  h[<span class="bu">abs</span>(h) <span class="op">&lt;=</span> <span class="fl">1e-4</span>] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb14-78"><a href="#cb14-78"></a>  <span class="cf">return</span> h</span>
<span id="cb14-79"><a href="#cb14-79"></a></span>
<span id="cb14-80"><a href="#cb14-80"></a></span>
<span id="cb14-81"><a href="#cb14-81"></a><span class="kw">def</span> halfband(hmat: np.ndarray, taps<span class="op">=</span><span class="dv">128</span>, transitionWidth<span class="op">=</span><span class="fl">0.03</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb14-82"><a href="#cb14-82"></a>  <span class="co">&quot;&quot;&quot;Decimate an array by half</span></span>
<span id="cb14-83"><a href="#cb14-83"></a></span>
<span id="cb14-84"><a href="#cb14-84"></a><span class="co">  Design a low-pass halfband filter with `taps` length and with transition band</span></span>
<span id="cb14-85"><a href="#cb14-85"></a><span class="co">  `transitionWidth` and apply it to the input array `hmat`, then throw away</span></span>
<span id="cb14-86"><a href="#cb14-86"></a><span class="co">  every other sample (2x downsample).</span></span>
<span id="cb14-87"><a href="#cb14-87"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb14-88"><a href="#cb14-88"></a>  hbFilter <span class="op">=</span> designHalfband(taps, transitionWidth)</span>
<span id="cb14-89"><a href="#cb14-89"></a>  doubleFilter <span class="op">=</span> convolve2d(</span>
<span id="cb14-90"><a href="#cb14-90"></a>      convolve2d(hmat, vec(hbFilter), mode<span class="op">=</span><span class="st">&#39;same&#39;</span>), vec(hbFilter).T, mode<span class="op">=</span><span class="st">&#39;same&#39;</span>)</span>
<span id="cb14-91"><a href="#cb14-91"></a>  n <span class="op">=</span> hmat.shape[<span class="dv">0</span>]</span>
<span id="cb14-92"><a href="#cb14-92"></a>  finalFilter <span class="op">=</span> doubleFilter[:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>, :<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>] <span class="cf">if</span> n <span class="op">%</span> <span class="dv">4</span> <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> doubleFilter[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>]</span>
<span id="cb14-93"><a href="#cb14-93"></a>  <span class="cf">return</span> finalFilter</span>
<span id="cb14-94"><a href="#cb14-94"></a></span>
<span id="cb14-95"><a href="#cb14-95"></a></span>
<span id="cb14-96"><a href="#cb14-96"></a><span class="kw">def</span> halfHankel(n: <span class="bu">int</span>,</span>
<span id="cb14-97"><a href="#cb14-97"></a>               alpha: <span class="bu">float</span>,</span>
<span id="cb14-98"><a href="#cb14-98"></a>               interpMethod<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb14-99"><a href="#cb14-99"></a>               sampleSpacing<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb14-100"><a href="#cb14-100"></a>               hbTaps<span class="op">=</span><span class="dv">128</span>,</span>
<span id="cb14-101"><a href="#cb14-101"></a>               hbTransitionWidth<span class="op">=</span><span class="fl">0.03</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb14-102"><a href="#cb14-102"></a>  <span class="co">&quot;&quot;&quot;Build the FIR filter approximating the fractional-Laplacian operator over</span></span>
<span id="cb14-103"><a href="#cb14-103"></a><span class="co">  all frequencies (ideal)</span></span>
<span id="cb14-104"><a href="#cb14-104"></a></span>
<span id="cb14-105"><a href="#cb14-105"></a><span class="co">  Returns an `n` by `n` array representing the spatial-domain FIR filter that</span></span>
<span id="cb14-106"><a href="#cb14-106"></a><span class="co">  approximates the `alpha`-detail fractional-Laplacian operator in its total</span></span>
<span id="cb14-107"><a href="#cb14-107"></a><span class="co">  frequency response. This should be used instead of `hankel.fullHankel`.</span></span>
<span id="cb14-108"><a href="#cb14-108"></a></span>
<span id="cb14-109"><a href="#cb14-109"></a><span class="co">  `interpMethod` and `sampleSpacing` keyword arguments per `hankel.fullHankel`,</span></span>
<span id="cb14-110"><a href="#cb14-110"></a><span class="co">  which generates the non-ideal spatial filter.</span></span>
<span id="cb14-111"><a href="#cb14-111"></a></span>
<span id="cb14-112"><a href="#cb14-112"></a><span class="co">  A half-band filter of `hbTaps` length and with transition band</span></span>
<span id="cb14-113"><a href="#cb14-113"></a><span class="co">  `hbTransitionWidth` is designed (via `hankel.designHalfband`) and used to</span></span>
<span id="cb14-114"><a href="#cb14-114"></a><span class="co">  decimate the output of `hankel.fullHankel`. This decimated array is returned.</span></span>
<span id="cb14-115"><a href="#cb14-115"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb14-116"><a href="#cb14-116"></a>  <span class="cf">return</span> halfband(</span>
<span id="cb14-117"><a href="#cb14-117"></a>      fullHankel(n, alpha, interpMethod<span class="op">=</span>interpMethod, sampleSpacing<span class="op">=</span>sampleSpacing),</span>
<span id="cb14-118"><a href="#cb14-118"></a>      taps<span class="op">=</span>hbTaps,</span>
<span id="cb14-119"><a href="#cb14-119"></a>      transitionWidth<span class="op">=</span>hbTransitionWidth)</span>
<span id="cb14-120"><a href="#cb14-120"></a></span>
<span id="cb14-121"><a href="#cb14-121"></a></span>
<span id="cb14-122"><a href="#cb14-122"></a><span class="kw">def</span> precomputeLoad(alpha: <span class="bu">float</span>, N: <span class="bu">int</span>, spacing: <span class="bu">float</span>) <span class="op">-&gt;</span> Dict[<span class="bu">str</span>, np.ndarray]:</span>
<span id="cb14-123"><a href="#cb14-123"></a>  <span class="co">&quot;&quot;&quot;Store and load gridded evaluations of the spatial-domain function</span></span>
<span id="cb14-124"><a href="#cb14-124"></a><span class="co">  `hankel.spatial` to disk</span></span>
<span id="cb14-125"><a href="#cb14-125"></a></span>
<span id="cb14-126"><a href="#cb14-126"></a><span class="co">  Given `alpha` the detail parameter of the fractional-Laplacian operator, and</span></span>
<span id="cb14-127"><a href="#cb14-127"></a><span class="co">  `N` and `spacing`, imagine generating `x = np.arange(0, N, spacing)`. This</span></span>
<span id="cb14-128"><a href="#cb14-128"></a><span class="co">  function will return `hankel.spatial` evaluated for each sample of that `x`.</span></span>
<span id="cb14-129"><a href="#cb14-129"></a></span>
<span id="cb14-130"><a href="#cb14-130"></a><span class="co">  The data is cached to the current directory, e.g., `hankel-alpha-0.8.npz` for</span></span>
<span id="cb14-131"><a href="#cb14-131"></a><span class="co">  `alpha=0.8`. This function will use as much of the pre-computed data from this</span></span>
<span id="cb14-132"><a href="#cb14-132"></a><span class="co">  NPZ file as possible, compute whatever is missing from this file, and update</span></span>
<span id="cb14-133"><a href="#cb14-133"></a><span class="co">  the file.</span></span>
<span id="cb14-134"><a href="#cb14-134"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb14-135"><a href="#cb14-135"></a>  <span class="im">import</span> os.path</span>
<span id="cb14-136"><a href="#cb14-136"></a>  fun <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x: spatial(x, alpha))</span>
<span id="cb14-137"><a href="#cb14-137"></a>  r <span class="op">=</span> np.arange(<span class="dv">0</span>, N, spacing)</span>
<span id="cb14-138"><a href="#cb14-138"></a>  fname <span class="op">=</span> <span class="st">&#39;hankel-alpha-</span><span class="sc">{}</span><span class="st">&#39;</span>.<span class="bu">format</span>(alpha)</span>
<span id="cb14-139"><a href="#cb14-139"></a>  <span class="cf">if</span> os.path.isfile(fname <span class="op">+</span> <span class="st">&#39;.npz&#39;</span>):</span>
<span id="cb14-140"><a href="#cb14-140"></a>    npz <span class="op">=</span> np.load(fname <span class="op">+</span> <span class="st">&#39;.npz&#39;</span>)</span>
<span id="cb14-141"><a href="#cb14-141"></a>    rsave <span class="op">=</span> npz[<span class="st">&#39;x&#39;</span>]</span>
<span id="cb14-142"><a href="#cb14-142"></a>    hsave <span class="op">=</span> npz[<span class="st">&#39;y&#39;</span>]</span>
<span id="cb14-143"><a href="#cb14-143"></a></span>
<span id="cb14-144"><a href="#cb14-144"></a>    rnew <span class="op">=</span> np.sort(np.setdiff1d(r, rsave))</span>
<span id="cb14-145"><a href="#cb14-145"></a>    hnew <span class="op">=</span> fun(rnew) <span class="cf">if</span> rnew.size <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> []</span>
<span id="cb14-146"><a href="#cb14-146"></a></span>
<span id="cb14-147"><a href="#cb14-147"></a>    r <span class="op">=</span> np.hstack([rsave, rnew])</span>
<span id="cb14-148"><a href="#cb14-148"></a>    h <span class="op">=</span> np.hstack([hsave, hnew])</span>
<span id="cb14-149"><a href="#cb14-149"></a>    idx <span class="op">=</span> np.argsort(r)  <span class="co"># wasteful but resorting 1k vec is fast</span></span>
<span id="cb14-150"><a href="#cb14-150"></a>    r <span class="op">=</span> r[idx]</span>
<span id="cb14-151"><a href="#cb14-151"></a>    h <span class="op">=</span> h[idx]</span>
<span id="cb14-152"><a href="#cb14-152"></a>  <span class="cf">else</span>:</span>
<span id="cb14-153"><a href="#cb14-153"></a>    h <span class="op">=</span> fun(r)</span>
<span id="cb14-154"><a href="#cb14-154"></a>  np.savez(fname, x<span class="op">=</span>r, y<span class="op">=</span>h)</span>
<span id="cb14-155"><a href="#cb14-155"></a>  <span class="cf">return</span> <span class="bu">dict</span>(r<span class="op">=</span>r, h<span class="op">=</span>h)</span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="co"># export hankel-demo.py</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="im">import</span> texshade</span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="im">import</span> postprocess</span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="im">from</span> scipy.signal <span class="im">import</span> fftconvolve</span>
<span id="cb15-6"><a href="#cb15-6"></a></span>
<span id="cb15-7"><a href="#cb15-7"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif.npy&#39;</span></span>
<span id="cb15-8"><a href="#cb15-8"></a>arr <span class="op">=</span> np.load(fname)</span>
<span id="cb15-9"><a href="#cb15-9"></a></span>
<span id="cb15-10"><a href="#cb15-10"></a>clip <span class="op">=</span> <span class="va">True</span></span>
<span id="cb15-11"><a href="#cb15-11"></a><span class="cf">if</span> clip:</span>
<span id="cb15-12"><a href="#cb15-12"></a>  arr <span class="op">=</span> arr[<span class="op">-</span><span class="dv">1500</span>:, <span class="dv">-1500</span>:]</span>
<span id="cb15-13"><a href="#cb15-13"></a></span>
<span id="cb15-14"><a href="#cb15-14"></a>alpha <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb15-15"><a href="#cb15-15"></a></span>
<span id="cb15-16"><a href="#cb15-16"></a>postprocess.texToPng(</span>
<span id="cb15-17"><a href="#cb15-17"></a>    texshade.texshadeFFT(arr, alpha),</span>
<span id="cb15-18"><a href="#cb15-18"></a>    <span class="st">&#39;orig-texshade-alpha-</span><span class="sc">{}{}</span><span class="st">.png&#39;</span>.<span class="bu">format</span>(alpha, <span class="st">&#39;-clip&#39;</span> <span class="cf">if</span> clip <span class="cf">else</span> <span class="st">&#39;&#39;</span>),</span>
<span id="cb15-19"><a href="#cb15-19"></a>    quantiles<span class="op">=</span>[.<span class="dv">01</span>, <span class="fl">.99</span>],</span>
<span id="cb15-20"><a href="#cb15-20"></a>    borderFractions<span class="op">=</span>[<span class="fl">1e-2</span>, <span class="fl">1e-2</span>])</span>
<span id="cb15-21"><a href="#cb15-21"></a></span>
<span id="cb15-22"><a href="#cb15-22"></a>Nwidth <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb15-23"><a href="#cb15-23"></a>Nhalfband <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb15-24"><a href="#cb15-24"></a></span>
<span id="cb15-25"><a href="#cb15-25"></a>h <span class="op">=</span> texshade.hankel.halfHankel(Nwidth, alpha, hbTaps<span class="op">=</span>Nhalfband)</span>
<span id="cb15-26"><a href="#cb15-26"></a><span class="bu">print</span>(<span class="st">&#39;halfbanded&#39;</span>, h.shape)</span>
<span id="cb15-27"><a href="#cb15-27"></a>postprocess.texToPng(</span>
<span id="cb15-28"><a href="#cb15-28"></a>    fftconvolve(arr, h, mode<span class="op">=</span><span class="st">&#39;same&#39;</span>),</span>
<span id="cb15-29"><a href="#cb15-29"></a>    <span class="st">&#39;hankel-texshade-alpha-</span><span class="sc">{}</span><span class="st">-n-</span><span class="sc">{}{}</span><span class="st">.png&#39;</span>.<span class="bu">format</span>(alpha, Nwidth, <span class="st">&#39;-clip&#39;</span> <span class="cf">if</span> clip <span class="cf">else</span> <span class="st">&#39;&#39;</span>),</span>
<span id="cb15-30"><a href="#cb15-30"></a>    quantiles<span class="op">=</span>[.<span class="dv">01</span>, <span class="fl">.99</span>],</span>
<span id="cb15-31"><a href="#cb15-31"></a>    borderFractions<span class="op">=</span>[<span class="fl">1e-2</span>, <span class="fl">1e-2</span>])</span>
<span id="cb15-32"><a href="#cb15-32"></a></span>
<span id="cb15-33"><a href="#cb15-33"></a>hFull <span class="op">=</span> texshade.hankel.fullHankel(Nwidth, alpha)</span>
<span id="cb15-34"><a href="#cb15-34"></a><span class="bu">print</span>(<span class="st">&#39;non-halfbanded&#39;</span>, hFull.shape)</span>
<span id="cb15-35"><a href="#cb15-35"></a>postprocess.texToPng(</span>
<span id="cb15-36"><a href="#cb15-36"></a>    fftconvolve(arr, hFull, mode<span class="op">=</span><span class="st">&#39;same&#39;</span>),</span>
<span id="cb15-37"><a href="#cb15-37"></a>    <span class="st">&#39;hankel-texshadeFullband-alpha-</span><span class="sc">{}</span><span class="st">-n-</span><span class="sc">{}{}</span><span class="st">.png&#39;</span>.<span class="bu">format</span>(alpha, Nwidth, <span class="st">&#39;-clip&#39;</span> <span class="cf">if</span> clip <span class="cf">else</span> <span class="st">&#39;&#39;</span>),</span>
<span id="cb15-38"><a href="#cb15-38"></a>    quantiles<span class="op">=</span>[.<span class="dv">01</span>, <span class="fl">.99</span>],</span>
<span id="cb15-39"><a href="#cb15-39"></a>    borderFractions<span class="op">=</span>[<span class="fl">1e-2</span>, <span class="fl">1e-2</span>])</span></code></pre></div>
<p>We can compare the output of the original texture shading algorithm:</p>
<p><img src="orig-texshade-alpha-0.8-clip.png" alt="Texshaded clip" /></p>
<p>with that of the Hankel approximation:</p>
<p><img src="hankel-texshade-alpha-0.8-n-500-clip.png" alt="Hankel-approximated texshaded clip" /></p>
<p>Both are very close. Toggling between them only reveals slight contrast differences due to the different levels obtained for the quantiles—these differences are likely caused by the artifacts at the edges.</p>
<p>In the above demo code, we ask Scipy's <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.fftconvolve.html"><code>fftconvolve</code></a> to apply the spatial-domain filtering, which behind the scenes uses a full-sized FFT just like the original method. However, we can make this much more memory-efficient, while retaining its speed, by using the overlap-add (or overlap-save) technique of fast-convolution.</p>
<h2 id="overlap-save-method-for-fast-convolution">Overlap-save method for fast-convolution</h2>
<p>The textbook definition of convolving two signals in the spatial domain is a quadratic \(O(N^2)\) operation. Since convolution in the spatial domain is mathematically equivalent to multiplication in the frequency domain, and the FFT is a log-linear \(O(N \log N)\) operation, this is usually much faster—this is why we use <code>fftconvolve</code> above. The drawback of the FFT-based alternative to direct convolution is that it requires we run the FFT on the signals of interest—with a potentially prohibitive memory burden.</p>
<p>The overlap-save method (and its closely-related sibling, the overlap-add method) allow us to convolve signals more intelligently: it still uses FFTs, so the overall theoretical runtime complexity remains log-linear, but it uses <em>many small</em> FFTs so memory consumption remains reasonable. I prefer overlap-save because it partitions the <em>output</em> array into non-overlapping segments that each step of the algorithm fills in (and which may be parallelized). Each step of the overlap-save algorithm reaches for segments of <em>input</em> that may overlap with other steps, but this overlap is read-only.</p>
<blockquote>
<p>In contrast, overlap-add splits the <em>input</em> array into non-overlapping segments. Each step of that algorithm has to potentially modify previously-computed samples of the <em>output</em>, which makes parallelization much more nasty (requiring locks or careful orchestration of the sequence of steps).</p>
</blockquote>
<p>The overlap-save implementation I wrote is largely out of the scope of this texture shading library, so let's just import it and show how we can use it, along with memory-mapped inputs and outputs to <em>really</em> save memory.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># export texshade/texshade.py</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="im">from</span> ols <span class="im">import</span> ols</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="im">from</span> .hankel <span class="im">import</span> halfHankel</span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="kw">def</span> texshadeSpatial(</span>
<span id="cb16-7"><a href="#cb16-7"></a>    x: np.ndarray,</span>
<span id="cb16-8"><a href="#cb16-8"></a>    alpha: <span class="bu">float</span>,</span>
<span id="cb16-9"><a href="#cb16-9"></a>    <span class="co"># halfHankel args</span></span>
<span id="cb16-10"><a href="#cb16-10"></a>    nDiameter: <span class="bu">int</span>,</span>
<span id="cb16-11"><a href="#cb16-11"></a>    <span class="co"># halfHankel kwargs</span></span>
<span id="cb16-12"><a href="#cb16-12"></a>    interpMethod<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb16-13"><a href="#cb16-13"></a>    sampleSpacing<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb16-14"><a href="#cb16-14"></a>    hbTaps<span class="op">=</span><span class="dv">128</span>,</span>
<span id="cb16-15"><a href="#cb16-15"></a>    hbTransitionWidth<span class="op">=</span><span class="fl">0.03</span>,</span>
<span id="cb16-16"><a href="#cb16-16"></a>    <span class="co"># ols kwargs</span></span>
<span id="cb16-17"><a href="#cb16-17"></a>    size<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb16-18"><a href="#cb16-18"></a>    nfft<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb16-19"><a href="#cb16-19"></a>    out<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb16-20"><a href="#cb16-20"></a>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb16-21"><a href="#cb16-21"></a>  <span class="co">&quot;&quot;&quot;Low-memory approximation of the texture shading algorithm</span></span>
<span id="cb16-22"><a href="#cb16-22"></a></span>
<span id="cb16-23"><a href="#cb16-23"></a><span class="co">  Unlike `texshade.texshadeFFT`, which computes an FFT of the entire input</span></span>
<span id="cb16-24"><a href="#cb16-24"></a><span class="co">  elevation array `x` and applies the fractional-Laplacian filter in the</span></span>
<span id="cb16-25"><a href="#cb16-25"></a><span class="co">  frequency domain, this function approximates that frequency response with a</span></span>
<span id="cb16-26"><a href="#cb16-26"></a><span class="co">  spatial-domain finite impulse response (FIR) filter that is applied in the</span></span>
<span id="cb16-27"><a href="#cb16-27"></a><span class="co">  spatial domain via fast-convolution (overlap-save method). This allows `x` to</span></span>
<span id="cb16-28"><a href="#cb16-28"></a><span class="co">  be memory-mapped and/or very large relative to the amount of free system</span></span>
<span id="cb16-29"><a href="#cb16-29"></a><span class="co">  memory.</span></span>
<span id="cb16-30"><a href="#cb16-30"></a></span>
<span id="cb16-31"><a href="#cb16-31"></a><span class="co">  `alpha` is the shading detail factor, i.e., the power of the</span></span>
<span id="cb16-32"><a href="#cb16-32"></a><span class="co">  fractional-Laplacian operator. `alpha=0` means no detail (output is the</span></span>
<span id="cb16-33"><a href="#cb16-33"></a><span class="co">  input). `alpha=2.0` is the full (non-fractional) Laplacian operator and is</span></span>
<span id="cb16-34"><a href="#cb16-34"></a><span class="co">  probably too high. `alpha &lt;= 1.0` seem aesthetically pleasing.</span></span>
<span id="cb16-35"><a href="#cb16-35"></a></span>
<span id="cb16-36"><a href="#cb16-36"></a><span class="co">  Returns an array the same dimensions as `x` that contains the texture-shaded</span></span>
<span id="cb16-37"><a href="#cb16-37"></a><span class="co">  version of the input array.</span></span>
<span id="cb16-38"><a href="#cb16-38"></a></span>
<span id="cb16-39"><a href="#cb16-39"></a><span class="co">  `nDiameter` specifies the size of the spatial-domain FIR filter to apply to</span></span>
<span id="cb16-40"><a href="#cb16-40"></a><span class="co">  `x`. It is in the same units as `x`. The larger this is, the closer the output</span></span>
<span id="cb16-41"><a href="#cb16-41"></a><span class="co">  will be to the return value of `texshade.texshadeFFT`. This number controls</span></span>
<span id="cb16-42"><a href="#cb16-42"></a><span class="co">  the size of the neighborhood around a given pixel that contribute to that</span></span>
<span id="cb16-43"><a href="#cb16-43"></a><span class="co">  pixel&#39;s final texture-shaded value. If this is too small, the output will</span></span>
<span id="cb16-44"><a href="#cb16-44"></a><span class="co">  differ significantly from the full texture shading algorithm. If it is too</span></span>
<span id="cb16-45"><a href="#cb16-45"></a><span class="co">  big, you may run out of memory, because the overlap-save algorithm for</span></span>
<span id="cb16-46"><a href="#cb16-46"></a><span class="co">  fast-convolution will compute FFTs *at least* this size.</span></span>
<span id="cb16-47"><a href="#cb16-47"></a></span>
<span id="cb16-48"><a href="#cb16-48"></a><span class="co">  **Spatial filter generation keyword args** passed to</span></span>
<span id="cb16-49"><a href="#cb16-49"></a><span class="co">  `texshade.hankel.halfHankel`: see that function&#39;s docstring for details, but</span></span>
<span id="cb16-50"><a href="#cb16-50"></a><span class="co">  reasonable values are chosen for these:</span></span>
<span id="cb16-51"><a href="#cb16-51"></a></span>
<span id="cb16-52"><a href="#cb16-52"></a><span class="co">  - `interpMethod`</span></span>
<span id="cb16-53"><a href="#cb16-53"></a><span class="co">  - `sampleSpacing`</span></span>
<span id="cb16-54"><a href="#cb16-54"></a><span class="co">  - `hbTaps`</span></span>
<span id="cb16-55"><a href="#cb16-55"></a><span class="co">  - `hbTransitionWidth`</span></span>
<span id="cb16-56"><a href="#cb16-56"></a></span>
<span id="cb16-57"><a href="#cb16-57"></a><span class="co">  **Overlap-save keyword args** passed to `ols.ols` (this function is in the</span></span>
<span id="cb16-58"><a href="#cb16-58"></a><span class="co">  `overlap-save` module on PyPI):</span></span>
<span id="cb16-59"><a href="#cb16-59"></a></span>
<span id="cb16-60"><a href="#cb16-60"></a><span class="co">  - `size`</span></span>
<span id="cb16-61"><a href="#cb16-61"></a><span class="co">  - `nfft`</span></span>
<span id="cb16-62"><a href="#cb16-62"></a><span class="co">  - `out`</span></span>
<span id="cb16-63"><a href="#cb16-63"></a></span>
<span id="cb16-64"><a href="#cb16-64"></a><span class="co">  `size`, a 2-list, specifies the size of the sub-arrays of the texture-shaded</span></span>
<span id="cb16-65"><a href="#cb16-65"></a><span class="co">  output to compute in each overlap-save step, while `nfft` (also a 2-list) is</span></span>
<span id="cb16-66"><a href="#cb16-66"></a><span class="co">  the size of the zero-padded FFT that will be taken at each overlap-save FFT.</span></span>
<span id="cb16-67"><a href="#cb16-67"></a><span class="co">  The requirement is that `nfft &gt;= size + nDiameter - 1` for both dimensions. If</span></span>
<span id="cb16-68"><a href="#cb16-68"></a><span class="co">  `nfft` isn&#39;t provided, suitable numbers with small prime factors will be</span></span>
<span id="cb16-69"><a href="#cb16-69"></a><span class="co">  selected. If `size` isn&#39;t specified, a small multiple of `nDiameter` is</span></span>
<span id="cb16-70"><a href="#cb16-70"></a><span class="co">  chosen.</span></span>
<span id="cb16-71"><a href="#cb16-71"></a><span class="co">  </span></span>
<span id="cb16-72"><a href="#cb16-72"></a><span class="co">  N.B. It is beneficial to make `size` as big as can fit in your system memory.</span></span>
<span id="cb16-73"><a href="#cb16-73"></a><span class="co">  Suppose `nDiameter` is 1000. If you make `size=[15*1024, 15*1024]`,</span></span>
<span id="cb16-74"><a href="#cb16-74"></a><span class="co">  overlap-save will pick `nfft=[16*1024, 16*1024]` or a bit smaller. A 16k by</span></span>
<span id="cb16-75"><a href="#cb16-75"></a><span class="co">  16k array of float64 (actually, they&#39;ll be complex128, but the real-only FFT</span></span>
<span id="cb16-76"><a href="#cb16-76"></a><span class="co">  will only need half as much space, due to Fourier symmetry) uses 2 GB of</span></span>
<span id="cb16-77"><a href="#cb16-77"></a><span class="co">  memory. You&#39;ll probably need 4x this much to store all the intermediate</span></span>
<span id="cb16-78"><a href="#cb16-78"></a><span class="co">  FFT-related arrays:</span></span>
<span id="cb16-79"><a href="#cb16-79"></a></span>
<span id="cb16-80"><a href="#cb16-80"></a><span class="co">  1. the FFT of the spatial filter,</span></span>
<span id="cb16-81"><a href="#cb16-81"></a><span class="co">  2. the FFT of the roughly 16k by 16k chunk of input</span></span>
<span id="cb16-82"><a href="#cb16-82"></a><span class="co">  3. the product of the two</span></span>
<span id="cb16-83"><a href="#cb16-83"></a><span class="co">  4. the inverse-FFT of the product</span></span>
<span id="cb16-84"><a href="#cb16-84"></a></span>
<span id="cb16-85"><a href="#cb16-85"></a><span class="co">  I assume your input pixels are int16 or float32, so much smaller before FFT</span></span>
<span id="cb16-86"><a href="#cb16-86"></a><span class="co">  than after. So if your system has 8 GB free, you could pick `size=[15*1024,</span></span>
<span id="cb16-87"><a href="#cb16-87"></a><span class="co">  15*1024]`. A rough equation might be, if your system has `M` GB, let each</span></span>
<span id="cb16-88"><a href="#cb16-88"></a><span class="co">  element of `size` be roughly `np.sqrt(M / 4 * 1024**3 / 8) - nDiameter`.</span></span>
<span id="cb16-89"><a href="#cb16-89"></a></span>
<span id="cb16-90"><a href="#cb16-90"></a><span class="co">  `out` allows you to specify the output array to store the results in. This is</span></span>
<span id="cb16-91"><a href="#cb16-91"></a><span class="co">  useful when you have a memory-mapped array prepared to accept the output of</span></span>
<span id="cb16-92"><a href="#cb16-92"></a><span class="co">  the algorithm, which will be float64. If `out.dtype` is not `float64`, then</span></span>
<span id="cb16-93"><a href="#cb16-93"></a><span class="co">  Numpy will perform a conversion, which might be expensive. If provided, this</span></span>
<span id="cb16-94"><a href="#cb16-94"></a><span class="co">  is returned. If not specified, a new array is allocated, filled, and returned.</span></span>
<span id="cb16-95"><a href="#cb16-95"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb16-96"><a href="#cb16-96"></a>  h <span class="op">=</span> halfHankel(</span>
<span id="cb16-97"><a href="#cb16-97"></a>      nDiameter,</span>
<span id="cb16-98"><a href="#cb16-98"></a>      alpha,</span>
<span id="cb16-99"><a href="#cb16-99"></a>      interpMethod<span class="op">=</span>interpMethod,</span>
<span id="cb16-100"><a href="#cb16-100"></a>      sampleSpacing<span class="op">=</span>sampleSpacing,</span>
<span id="cb16-101"><a href="#cb16-101"></a>      hbTaps<span class="op">=</span>hbTaps,</span>
<span id="cb16-102"><a href="#cb16-102"></a>      hbTransitionWidth<span class="op">=</span>hbTransitionWidth,</span>
<span id="cb16-103"><a href="#cb16-103"></a>  )</span>
<span id="cb16-104"><a href="#cb16-104"></a></span>
<span id="cb16-105"><a href="#cb16-105"></a>  <span class="cf">return</span> ols(x, h, size<span class="op">=</span>size, nfft<span class="op">=</span>nfft, out<span class="op">=</span>out)</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># export hankel-memmap.py</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="im">from</span> texshade <span class="im">import</span> texshadeSpatial</span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="im">import</span> postprocess</span>
<span id="cb17-5"><a href="#cb17-5"></a></span>
<span id="cb17-6"><a href="#cb17-6"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif.npy&#39;</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>arr <span class="op">=</span> np.load(fname, mmap_mode<span class="op">=</span><span class="st">&#39;r&#39;</span>)</span>
<span id="cb17-8"><a href="#cb17-8"></a></span>
<span id="cb17-9"><a href="#cb17-9"></a>alpha <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>Nwidth <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>Nhalfband <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb17-12"><a href="#cb17-12"></a></span>
<span id="cb17-13"><a href="#cb17-13"></a>tex <span class="op">=</span> np.lib.<span class="bu">format</span>.open_memmap(<span class="st">&#39;mmap-tex.npy&#39;</span>, mode<span class="op">=</span><span class="st">&#39;w+&#39;</span>, dtype<span class="op">=</span>np.float64, shape<span class="op">=</span>arr.shape)</span>
<span id="cb17-14"><a href="#cb17-14"></a></span>
<span id="cb17-15"><a href="#cb17-15"></a>texshadeSpatial(arr, alpha, Nwidth, hbTaps<span class="op">=</span>Nhalfband, out<span class="op">=</span>tex, size<span class="op">=</span>[<span class="dv">2000</span>, <span class="dv">2000</span>])</span>
<span id="cb17-16"><a href="#cb17-16"></a></span>
<span id="cb17-17"><a href="#cb17-17"></a>postprocess.texToPng(</span>
<span id="cb17-18"><a href="#cb17-18"></a>    tex,</span>
<span id="cb17-19"><a href="#cb17-19"></a>    <span class="st">&#39;hankel-texshade-alpha-</span><span class="sc">{}</span><span class="st">-n-</span><span class="sc">{}</span><span class="st">-mmap.png&#39;</span>.<span class="bu">format</span>(alpha, Nwidth),</span>
<span id="cb17-20"><a href="#cb17-20"></a>    quantiles<span class="op">=</span>[.<span class="dv">01</span>, <span class="fl">.99</span>],</span>
<span id="cb17-21"><a href="#cb17-21"></a>    borderFractions<span class="op">=</span>[<span class="fl">1e-2</span>, <span class="fl">1e-2</span>])</span></code></pre></div>
<p>To downsample this large image for including with this repo:</p>
<pre><code>convert -filter Mitchell -sampling-factor 1x1 -quality 90 -resize 2048 hankel-texshade-alpha-0.8-n-500-mmap.png hankel-texshade-alpha-0.8-n-500-mmap.png.small.png</code></pre>
<p><img src="hankel-texshade-alpha-0.8-n-500-mmap.png.small.png" alt="Memory-efficient tex-shading via memory-mapped files and overlap-save technique of fast convolution" /></p>
<p>This image is qualitatively identical to the original texture-shaded output <a href="#tex-shaded">previously shown</a> but to reemphasize: while the <a href="#tex-shaded">original</a> texture-shaded image involved slurping the entire dataset into memory, and then computing huge FFTs of it, the image just above, generated by the <code>hankel-memmap.py</code> script, sipped memory: it loaded the input array as a memory-mapped file, allocated the output as a memory-mapped file, and used a spatial-domain filter to approximate the frequency-domain operator in the original image. By using the overlap-save method of fast-convolution, the filter was applied on small chunks of the data.</p>
<p>We can finally run the texture shading algorithm on enormous datasets without needing gargantuan amounts of memory.</p>
<h2 id="developing-in-this-repository">Developing in this repository</h2>
<p>I edit README.md in any old text editor as a Knuth-style <a href="https://en.wikipedia.org/wiki/Literate_programming">literate program</a>, and run <code>$ node md2code.js</code> to</p>
<ul>
<li>tangle it into Python code, and running the <a href="https://github.com/google/yapf">Yapf</a> Python code formatter on it, and</li>
<li>gently weave the Markdown again with the Yapf-formatted code.</li>
</ul>
<p>If you want to use <a href="./mdcode.js"><code>md2code.js</code></a> (which is totally uncommented and ad hoc), install <a href="https://nodejs.org">Node.js</a> and run <code>$ npm i</code> in this repo.</p>
<p>To build the HTML, I use Pandoc and coordinate it with the <a href="./Makefile"><code>Makefile</code></a>, which can be invoked by running <code>$ make</code>.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>John Otander's <a href="http://markdowncss.github.io/retro/">Retro</a> CSS theme. KaTeX for rendering equations.</p>
