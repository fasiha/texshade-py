<!DOCTYPE html>

<head>
  <meta charset="utf-8">
  <title>Texshade: texture-shaded elevation via the fractional-Laplacian operator</title>
  <link rel="stylesheet" href="assets/retro.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css"
    integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js"
    integrity="sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1"
    crossorigin="anonymous"></script>

  <!-- To automatically render math in text elements, include the auto-render extension: -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js"
    integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters: [
      {left: '$$', right: '$$', display: true},
    {left: '\\(', right: '\\)', display: false}
]});"></script>

  <script>
    window.WebFontConfig = {
      custom: {
        families: ['KaTeX_AMS', 'KaTeX_Caligraphic:n4,n7', 'KaTeX_Fraktur:n4,n7',
          'KaTeX_Main:n4,n7,i4,i7', 'KaTeX_Math:i4,i7', 'KaTeX_Script',
          'KaTeX_SansSerif:n4,n7,i4', 'KaTeX_Size1', 'KaTeX_Size2', 'KaTeX_Size3',
          'KaTeX_Size4', 'KaTeX_Typewriter'],
      },
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js"
    integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script>

  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }
  </style>
  <style>
    <style>code.sourceCode>span {
      display: inline-block;
      line-height: 1.25;
    }

    code.sourceCode>span {
      color: inherit;
      text-decoration: inherit;
    }

    code.sourceCode>span:empty {
      height: 1.2em;
    }

    .sourceCode {
      overflow: visible;
    }

    code.sourceCode {
      white-space: pre;
      position: relative;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      code.sourceCode {
        white-space: pre-wrap;
      }

      code.sourceCode>span {
        text-indent: -5em;
        padding-left: 5em;
      }
    }

    pre.numberSource code {
      counter-reset: source-line 0;
    }

    pre.numberSource code>span {
      position: relative;
      left: -4em;
      counter-increment: source-line;
    }

    pre.numberSource code>span>a:first-child::before {
      content: counter(source-line);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
      background-color: #232629;
      color: #7a7c7d;
    }

    pre.numberSource {
      margin-left: 3em;
      border-left: 1px solid #7a7c7d;
      padding-left: 4px;
    }

    div.sourceCode {
      color: #cfcfc2;
      background-color: #232629;
    }

    @media screen {
      code.sourceCode>span>a:first-child::before {
        text-decoration: underline;
      }
    }

    code span. {
      color: #cfcfc2;
    }

    /* Normal */
    code span.al {
      color: #95da4c;
    }

    /* Alert */
    code span.an {
      color: #3f8058;
    }

    /* Annotation */
    code span.at {
      color: #2980b9;
    }

    /* Attribute */
    code span.bn {
      color: #f67400;
    }

    /* BaseN */
    code span.bu {
      color: #7f8c8d;
    }

    /* BuiltIn */
    code span.cf {
      color: #fdbc4b;
    }

    /* ControlFlow */
    code span.ch {
      color: #3daee9;
    }

    /* Char */
    code span.cn {
      color: #27aeae;
    }

    /* Constant */
    code span.co {
      color: #7a7c7d;
    }

    /* Comment */
    code span.cv {
      color: #7f8c8d;
    }

    /* CommentVar */
    code span.do {
      color: #a43340;
    }

    /* Documentation */
    code span.dt {
      color: #2980b9;
    }

    /* DataType */
    code span.dv {
      color: #f67400;
    }

    /* DecVal */
    code span.er {
      color: #da4453;
    }

    /* Error */
    code span.ex {
      color: #0099ff;
    }

    /* Extension */
    code span.fl {
      color: #f67400;
    }

    /* Float */
    code span.fu {
      color: #8e44ad;
    }

    /* Function */
    code span.im {
      color: #27ae60;
    }

    /* Import */
    code span.in {
      color: #c45b00;
    }

    /* Information */
    code span.kw {
      color: #cfcfc2;
    }

    /* Keyword */
    code span.op {
      color: #cfcfc2;
    }

    /* Operator */
    code span.ot {
      color: #27ae60;
    }

    /* Other */
    code span.pp {
      color: #27ae60;
    }

    /* Preprocessor */
    code span.re {
      color: #2980b9;
    }

    /* RegionMarker */
    code span.sc {
      color: #3daee9;
    }

    /* SpecialChar */
    code span.ss {
      color: #da4453;
    }

    /* SpecialString */
    code span.st {
      color: #f44f4f;
    }

    /* String */
    code span.va {
      color: #27aeae;
    }

    /* Variable */
    code span.vs {
      color: #da4453;
    }

    /* VerbatimString */
    code span.wa {
      color: #da4453;
    }

    /* Warning */
  </style>

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->

</head><h1 id="texshade-texture-shaded-elevation-via-the-fractional-laplacian-operator">Texshade: texture-shaded elevation via the fractional-Laplacian operator</h1>
<h2 id="introduction">Introduction</h2>
<p>See <a href="http://www.textureshading.com/Home.html" class="uri">http://www.textureshading.com/Home.html</a> for links to papers and slides by Leland Brown from 2010 and 2014 describing the technique of texture shading, but in summary, it is a method of processing digital elevation maps (DEMs) that highlights the network nature of topography, throwing ridges, canyons, and valleys into sharp relief.</p>
<p>This repository contains an open-source public-domain Python/Numpy software library to apply the texture shading algorithm on <em>extremely</em> large datasets. This is a challenge because a straightforward implementation of the texture-shading technique requires loading the entire elevation map into memory. For large datasets—like the ASTER Global DEM, which comes in at roughly 250 GB compressed—you either have to find a computer with a lot of memory (nodes with 1 TB RAM are available at many scientific organizations as of 2018) or you have to modify the technique.</p>
<p>This repository contains (1) mathematical and (2) software details of a low-memory approximation to the original texture-shading algorithm that in practice produces texture-shaded imagery very similar to the full algorithm.</p>
<p>The mathematical trick, in a nutshell, is to use the Hankel transform to find a finite impulse response (FIR) filter that approximates the frequency-domain fractional-Laplacian operator, and apply that filter in the spatial domain via the efficient overlap-save algorithm. According to GitHub commit logs, I first derived this technique in 2015.</p>
<h2 id="the-texture-shading-algorithm">The texture-shading algorithm</h2>
<p>The original texture-shading algorithm takes a 2D array of elevations, call it \(x\), and computes the texture-shaded elevation map,</p>
<p>$$y = F^{-1}[F[x] ⋅ |\vec f|^α],$$</p>
<p>where</p>
<ul>
<li>\(F[\cdot]\) is the 2D Fourier transform operator and \(F^{-1}[\cdot]\) its inverse</li>
<li>\(\vec f = [f_x, f_y]'\) the 2D vector of Fourier coordinates, so \(|\vec f|^α=(f_x^2 + f_y^2)^{α/2}\)</li>
<li>\(()'\) indicates matrix or vector transpose</li>
<li>\(0&lt;α≤1\), the "fraction" in the fractional-Laplacian (though Brown gives examples of \(α≤2\)!).</li>
</ul>
<p>While many details of the algorithm have yet to be specified, the output array \(y\) can be made to have the same size as the input \(x\).</p>
<p>Let's implement this in Python.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># export texshade/texshade.py</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> scipy.fftpack <span class="im">as</span> scifft</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a>nextpow2 <span class="op">=</span> <span class="kw">lambda</span> v: <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="dv">2</span><span class="op">**</span>np.ceil(np.log2(v))))</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">def</span> texshade(x, alpha, verbose<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb1-9"><a href="#cb1-9"></a>  Nyx <span class="op">=</span> nextpow2(x.shape)</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a>  fy <span class="op">=</span> scifft.rfftfreq(Nyx[<span class="dv">0</span>])[:, np.newaxis].astype(x.dtype)</span>
<span id="cb1-12"><a href="#cb1-12"></a>  fx <span class="op">=</span> scifft.rfftfreq(Nyx[<span class="dv">1</span>])[np.newaxis, :].astype(x.dtype)</span>
<span id="cb1-13"><a href="#cb1-13"></a>  H2 <span class="op">=</span> (fx<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> fy<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span>(alpha <span class="op">/</span> <span class="fl">2.0</span>)</span>
<span id="cb1-14"><a href="#cb1-14"></a>  <span class="cf">if</span> verbose:</span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="bu">print</span>(<span class="st">&quot;Generated filter&quot;</span>)</span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>  rfft2 <span class="op">=</span> <span class="kw">lambda</span> x: scifft.rfft(scifft.rfft(x, Nyx[<span class="dv">1</span>], <span class="dv">1</span>, <span class="va">True</span>), Nyx[<span class="dv">0</span>], <span class="dv">0</span>, <span class="va">True</span>)</span>
<span id="cb1-18"><a href="#cb1-18"></a>  irfft2 <span class="op">=</span> <span class="kw">lambda</span> X: scifft.irfft(scifft.irfft(X, axis<span class="op">=</span><span class="dv">0</span>, overwrite_x<span class="op">=</span><span class="va">True</span>), overwrite_x<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-19"><a href="#cb1-19"></a></span>
<span id="cb1-20"><a href="#cb1-20"></a>  xr <span class="op">=</span> rfft2(x) <span class="op">*</span> H2</span>
<span id="cb1-21"><a href="#cb1-21"></a>  <span class="cf">if</span> verbose:</span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="bu">print</span>(<span class="st">&quot;Completed frequency domain operations&quot;</span>)</span>
<span id="cb1-23"><a href="#cb1-23"></a>  H2 <span class="op">=</span> <span class="va">None</span>  <span class="co"># potentially trigger GC here to reclaim H2&#39;s memory</span></span>
<span id="cb1-24"><a href="#cb1-24"></a>  xr <span class="op">=</span> irfft2(xr)</span>
<span id="cb1-25"><a href="#cb1-25"></a>  <span class="cf">if</span> verbose:</span>
<span id="cb1-26"><a href="#cb1-26"></a>    <span class="bu">print</span>(<span class="st">&quot;Back to spatial-domain&quot;</span>)</span>
<span id="cb1-27"><a href="#cb1-27"></a></span>
<span id="cb1-28"><a href="#cb1-28"></a>  <span class="cf">return</span> xr[:x.shape[<span class="dv">0</span>], :x.shape[<span class="dv">1</span>]]</span></code></pre></div>
<h2 id="test-setup">Test setup</h2>
<p>I've downloaded three tiles from the SRTM DEM (from <a href="https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/">this page at SDSC.edu</a>) on the African coastline near 0° N and 0° W and merged them into a single raster using <a href="https://gdal.org/">GDAL</a>, which I installed using <a href="https://formulae.brew.sh/formula/gdal">Brew</a>: installing these is outside the scope of this document, but any DEM you have can be used.</p>
<pre><code>wget https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/N00E009.hgt \
  https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/N00E010.hgt \
  https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/N00E011.hgt
gdalwarp -of GTiff N00E009.hgt N00E010.hgt N00E011.hgt merged.tif</code></pre>
<p>Running <code>gdalinfo merged.tif</code> produces the following output:</p>
<pre><code>Driver: GTiff/GeoTIFF
Files: merged.tif
Size is 10801, 3601
Coordinate System is:
GEOGCS[&quot;WGS 84&quot;,
    DATUM[&quot;WGS_1984&quot;,
        SPHEROID[&quot;WGS 84&quot;,6378137,298.257223563,
            AUTHORITY[&quot;EPSG&quot;,&quot;7030&quot;]],
        AUTHORITY[&quot;EPSG&quot;,&quot;6326&quot;]],
    PRIMEM[&quot;Greenwich&quot;,0],
    UNIT[&quot;degree&quot;,0.0174532925199433],
    AUTHORITY[&quot;EPSG&quot;,&quot;4326&quot;]]
Origin = (8.999861111111111,1.000138888888889)
Pixel Size = (0.000277777777778,-0.000277777777778)
Metadata:
  AREA_OR_POINT=Point
Image Structure Metadata:
  INTERLEAVE=BAND
Corner Coordinates:
Upper Left  (   8.9998611,   1.0001389) (  8d59&#39;59.50&quot;E,  1d 0&#39; 0.50&quot;N)
Lower Left  (   8.9998611,  -0.0001389) (  8d59&#39;59.50&quot;E,  0d 0&#39; 0.50&quot;S)
Upper Right (  12.0001389,   1.0001389) ( 12d 0&#39; 0.50&quot;E,  1d 0&#39; 0.50&quot;N)
Lower Right (  12.0001389,  -0.0001389) ( 12d 0&#39; 0.50&quot;E,  0d 0&#39; 0.50&quot;S)
Center      (  10.5000000,   0.5000000) ( 10d30&#39; 0.00&quot;E,  0d30&#39; 0.00&quot;N)
Band 1 Block=10801x1 Type=Int16, ColorInterp=Gray
  NoData Value=-32768
  Unit Type: m</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># export convert.py</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">Quick script intended to be used only by a user to convert a specific</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">GeoTIF to a NPY file for pure-Numpy non-GDAL demo.</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="im">import</span> gdal, gdalconst</span>
<span id="cb4-8"><a href="#cb4-8"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif&#39;</span></span>
<span id="cb4-9"><a href="#cb4-9"></a></span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="kw">def</span> filenameToData(fname, dtype<span class="op">=</span>np.float32):</span>
<span id="cb4-12"><a href="#cb4-12"></a>  <span class="co">&quot;&quot;&quot;Reads all bands&quot;&quot;&quot;</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>  fileHandle <span class="op">=</span> gdal.Open(fname, gdalconst.GA_ReadOnly)</span>
<span id="cb4-14"><a href="#cb4-14"></a>  result <span class="op">=</span> np.squeeze(</span>
<span id="cb4-15"><a href="#cb4-15"></a>      np.dstack(</span>
<span id="cb4-16"><a href="#cb4-16"></a>          [fileHandle.GetRasterBand(n <span class="op">+</span> <span class="dv">1</span>).ReadAsArray() <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(fileHandle.RasterCount)]))</span>
<span id="cb4-17"><a href="#cb4-17"></a>  <span class="cf">if</span> dtype <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb4-18"><a href="#cb4-18"></a>    <span class="cf">return</span> result.astype(dtype)</span>
<span id="cb4-19"><a href="#cb4-19"></a>  <span class="cf">return</span> result</span>
<span id="cb4-20"><a href="#cb4-20"></a></span>
<span id="cb4-21"><a href="#cb4-21"></a></span>
<span id="cb4-22"><a href="#cb4-22"></a>np.save(fname, filenameToData(fname))</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># export demo.py</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="im">import</span> texshade</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-4"><a href="#cb5-4"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif.npy&#39;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a>arr <span class="op">=</span> np.load(fname)</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="bu">print</span>(arr)</span>
<span id="cb5-8"><a href="#cb5-8"></a>tex <span class="op">=</span> texshade.texshade(arr, <span class="fl">0.8</span>)</span>
<span id="cb5-9"><a href="#cb5-9"></a>np.save(fname <span class="op">+</span> <span class="st">&#39;.tex&#39;</span>, tex)</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># export postprocess.py</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">def</span> touint(x, cmin, cmax, dtype<span class="op">=</span>np.uint8):</span>
<span id="cb6-6"><a href="#cb6-6"></a>  <span class="co"># clamp x between cmin and cmax</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>  x[x <span class="op">&lt;</span> cmin] <span class="op">=</span> cmin</span>
<span id="cb6-8"><a href="#cb6-8"></a>  x[x <span class="op">&gt;</span> cmax] <span class="op">=</span> cmax</span>
<span id="cb6-9"><a href="#cb6-9"></a>  <span class="co"># map [cmin, cmax] to [0, 2**depth-1-eps] linearly</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>  maxval <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">8</span> <span class="op">*</span> dtype().itemsize) <span class="op">-</span> <span class="fl">1e-3</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>  slope <span class="op">=</span> (maxval <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">/</span> (cmax <span class="op">-</span> cmin)</span>
<span id="cb6-12"><a href="#cb6-12"></a>  ret <span class="op">=</span> slope <span class="op">*</span> (x <span class="op">-</span> cmin) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>  <span class="cf">return</span> (ret).astype(dtype)</span>
<span id="cb6-14"><a href="#cb6-14"></a></span>
<span id="cb6-15"><a href="#cb6-15"></a></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="kw">def</span> toPng(scaled, fname):</span>
<span id="cb6-17"><a href="#cb6-17"></a>  <span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb6-18"><a href="#cb6-18"></a>  newimage <span class="op">=</span> Image.new(<span class="st">&#39;L&#39;</span>, (scaled.shape[<span class="dv">1</span>], scaled.shape[<span class="dv">0</span>]))  <span class="co"># type, (width, height)</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>  newimage.putdata(scaled.ravel())</span>
<span id="cb6-20"><a href="#cb6-20"></a>  newimage.save(fname)</span>
<span id="cb6-21"><a href="#cb6-21"></a></span>
<span id="cb6-22"><a href="#cb6-22"></a></span>
<span id="cb6-23"><a href="#cb6-23"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</span>
<span id="cb6-24"><a href="#cb6-24"></a>  arr <span class="op">=</span> np.load(<span class="st">&#39;merged.tif.npy&#39;</span>)</span>
<span id="cb6-25"><a href="#cb6-25"></a>  tex <span class="op">=</span> np.load(<span class="st">&#39;merged.tif.npy.tex.npy&#39;</span>)</span>
<span id="cb6-26"><a href="#cb6-26"></a>  minmax <span class="op">=</span> np.quantile(tex.ravel(), [.<span class="dv">01</span>, <span class="fl">.99</span>])</span>
<span id="cb6-27"><a href="#cb6-27"></a>  scaled <span class="op">=</span> touint(tex, minmax[<span class="dv">0</span>], minmax[<span class="dv">1</span>], np.uint8)</span>
<span id="cb6-28"><a href="#cb6-28"></a>  toPng(scaled, <span class="st">&#39;scaled.png&#39;</span>)</span>
<span id="cb6-29"><a href="#cb6-29"></a>  toPng(touint(arr, np.<span class="bu">min</span>(arr), np.<span class="bu">max</span>(arr), np.uint8), <span class="st">&#39;orig.png&#39;</span>)</span></code></pre></div>
<pre><code>for i in orig.png scaled.png; do convert -filter Mitchell -sampling-factor 1x1 -quality 90 -resize 2048 \\(i \\)i.small.png; done</code></pre>
<h3 id="original">Original</h3>
<p><img src="orig.png.small.png" alt="original downsampled" /></p>
<h3 id="tex-shaded">Tex-shaded</h3>
<p><img src="scaled.png.small.png" alt="tex-shaded downsampled" /></p>
<h2 id="the-approximation">The approximation</h2>
<p>Is there any way to apply the fractional-Laplacian operator, which is expressed in the frequency-domain as \(|\vec f|^α ⋅ F[x]\) for an input array \(x\), that <em>doesn't</em> require a 2D Fourier transform of \(x\)? Recall that the Fourier transform is a unitary operator—that is, \(F[x]\) can be seen as a matrix–vector product \(\underline F ⋅ \underline x\), where the underlines represent a matrix or vector version of the operator or its input, and \(\underline F\) is a unitary matrix (the complex-domain extension of an orthogonal matrix). This indicates that each element of the output of a Fourier transform is a function of each of the input elements (though because it can do this in \(log(N)\) operations, instead of \(N\), we call it the <em>fast</em> Fourier transform (FFT)). There doesn't seem to be a memory-local way to convert the array of elevations to the Fourier domain, since each frequency bin has contributions from each pixel in the elevation array.</p>
<p>But we do know from linear systems theory that multiplication in the frequency domain is equivalent to convolution in the spatial domain. We can ask if there's any structure to the spatial-domain representation of the fractional-Laplacian \(|\vec f|^α\), i.e., what is \(F^{-1}[|\vec f|^α]\)?</p>
<p>Trawling through the Wikipedia I stumbled on <a href="https://en.wikipedia.org/w/index.php?title=Hankel_transform&amp;oldid=901300195#Relation_to_the_Fourier_transform_(circularly_symmetric_case)">the Hankel transform and its relationship to the Fourier transform of circularly-symmetric functions</a>. Wikipedia notes that for a two-dimensional radial function \(f(r)\), its two-dimensional Fourier transform \(F(\vec k)\) is</p>
<p>$$F(\vec k) = F(k) = 2π\int_0^{\infty} f(r) ⋅ J_0(k r) \cdot r ⋅ dr,$$ where \(J_0(⋅)\) is the Bessel function of the first kind of order 0. In our notation, if we represent the fractional-Laplacian operator as \(l(\vec f) = l(f) = f^α\) ("l" for "Laplacian"), its Fourier transform is, according to <a href="https://www.wolframalpha.com/input/?i=2*pi*Integrate%5Bf%5Ea+*+BesselJ%5B0%2C+k+*+f%5D+*+f%2C+f%2C+0%2C+m%5D">Wolfram Alpha</a>,</p>
<p>$$2π\int_0^m f ⋅ f^α J_0(f r) df = 2π \frac{m^{α + 2}}{α + 2} \cdot {}_{1}F_2([α / 2 + 1], [1, α / 2 + 2], -(r ⋅ m / 2)^2)$$ where</p>
<ul>
<li>\(r\) is my variable for the radius in the spatial domain,</li>
<li>\(1F2\) is a generalized hypergeometric function (not "the" hypergeometric function \(2F1\)!), and</li>
<li>where I left the upper limit of the integral as \(m\) (for "max") because we have a bound on the extent of the frequency domain \(\vec f = [f_x, f_y]'\), since \(-π ≤ f_x &lt; π\) radians per pixel, and same for \(f_y\). (Recall this happens because we are working with a discrete-valued array of elevations \(x\), so the Fourier transform is a discrete-time Fourier transform (DTFT) and is periodic every 2π radians per pixel.)</li>
</ul>
<blockquote>
<p>Odd sidebar. My little knowledge of mathematics is exhausted by wondering why, if I omit the 2π in the expression to Wolfram Alpha, it returns a much more complicated expression including Γ functions. Sympy similar story.</p>
</blockquote>
<p>The constant factors that accrete when working with Fourier transform pairs are usually incredibly tedious to keep track of, especially when evaluating them with the FFT. My normal practice is to get things working up to a constant factor and then see if I need to worry about that factor.</p>
<p>So let us ask what the Fourier transform of an array containing evaluations of the radial function</p>
<p>$$L(r) = {}_{1}F_2([α / 2 + 1], [1, α / 2 + 2], -(r ⋅ π / 2)^2).$$ We use the maximum of the integral in the Hankel transform is \(m=π\). Recall we use "l" and "L" for "Laplacian": \(L(r)\) is the Fourier transform of the fractional-Laplacian \(l(f) = |f|^α\).</p>
<p>We do this in the code snippet below: we evaluate the above generalized hypergeometric function on a 200×200 array of radii. We assume the array's horizontal and vertical axes run from -100 to 99, i.e., assuming one pixel spacing for each element, compute each element's radius \(r\), and evaluate \(L(r)\). Then we look at its 2D FFT, which will be all-real because the input is symmetric. (Recall that in general, the Fourier transform of a real vector will contain complex entries but be conjugate-symmetric about the origin. The Fourier transform will contain zero imaginary components only if its input was symmetric about the origin.)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># export math-hankel.py</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="im">from</span> mpmath <span class="im">import</span> hyper</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="im">import</span> numpy.fft <span class="im">as</span> fft</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="im">import</span> pylab <span class="im">as</span> plt</span>
<span id="cb8-6"><a href="#cb8-6"></a>plt.style.use(<span class="st">&#39;ggplot&#39;</span>)</span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="kw">def</span> spatial(r, a):</span>
<span id="cb8-10"><a href="#cb8-10"></a>  <span class="co">&quot;Evaluate L(r), proportional to the Fourier transform of |f|**α&quot;</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>  <span class="cf">return</span> <span class="bu">float</span>(hyper((<span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">1</span>,), (<span class="fl">1.0</span>, <span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">2</span>), <span class="fl">-0.25</span> <span class="op">*</span> (r <span class="op">*</span> np.pi)<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb8-12"><a href="#cb8-12"></a></span>
<span id="cb8-13"><a href="#cb8-13"></a></span>
<span id="cb8-14"><a href="#cb8-14"></a>xmat, ymat <span class="op">=</span> np.meshgrid(np.arange(<span class="op">-</span><span class="dv">100</span>, <span class="dv">100</span>), np.arange(<span class="op">-</span><span class="dv">100</span>, <span class="dv">100</span>))</span>
<span id="cb8-15"><a href="#cb8-15"></a>rmat <span class="op">=</span> np.sqrt(xmat<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ymat<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb8-16"><a href="#cb8-16"></a>alpha <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb8-17"><a href="#cb8-17"></a>h <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> r: spatial(r, alpha))(rmat)</span></code></pre></div>
<p>Above we use the fabulous <a href="http://mpmath.org/"><code>mpmath</code></a> package—a pure-Python arbitrary-precision package with extensive support for special functions, quadrature integration, linear algebra, etc., started by Fredrik Johansson in 2007 (when he was a teenager)—to compute the generalized hypergeometric function. Next, we'd like to visualize its Fourier transform—hopefully we see something that looks like \(|f|^{0.8}\).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># export math-hankel.py</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">def</span> F2cent(arr):</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="co">&quot;&quot;&quot;Origin-centered 2D Fourier transform&quot;&quot;&quot;</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>  <span class="cf">return</span> fft.fftshift(fft.fft2(fft.ifftshift(arr)))</span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw">def</span> plotF2cent(arr):</span>
<span id="cb9-8"><a href="#cb9-8"></a>  <span class="co">&quot;&quot;&quot;Given an origin-centered 2D array, plot its 2D Fourier transform&quot;&quot;&quot;</span></span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a>  <span class="kw">def</span> extents(f):</span>
<span id="cb9-11"><a href="#cb9-11"></a>    delta <span class="op">=</span> f[<span class="dv">1</span>] <span class="op">-</span> f[<span class="dv">0</span>]</span>
<span id="cb9-12"><a href="#cb9-12"></a>    <span class="cf">return</span> [f[<span class="dv">0</span>] <span class="op">-</span> delta <span class="op">/</span> <span class="dv">2</span>, f[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> delta <span class="op">/</span> <span class="dv">2</span>]</span>
<span id="cb9-13"><a href="#cb9-13"></a></span>
<span id="cb9-14"><a href="#cb9-14"></a>  h, w <span class="op">=</span> arr.shape</span>
<span id="cb9-15"><a href="#cb9-15"></a>  x <span class="op">=</span> np.ceil(np.arange(w) <span class="op">-</span> w <span class="op">/</span> <span class="dv">2</span>) <span class="op">/</span> w</span>
<span id="cb9-16"><a href="#cb9-16"></a>  y <span class="op">=</span> np.ceil(np.arange(h) <span class="op">-</span> h <span class="op">/</span> <span class="dv">2</span>) <span class="op">/</span> h</span>
<span id="cb9-17"><a href="#cb9-17"></a>  fig, (sax, fax) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb9-18"><a href="#cb9-18"></a></span>
<span id="cb9-19"><a href="#cb9-19"></a>  sax.imshow(</span>
<span id="cb9-20"><a href="#cb9-20"></a>      arr,</span>
<span id="cb9-21"><a href="#cb9-21"></a>      aspect<span class="op">=</span><span class="st">&#39;equal&#39;</span>,</span>
<span id="cb9-22"><a href="#cb9-22"></a>      interpolation<span class="op">=</span><span class="st">&#39;none&#39;</span>,</span>
<span id="cb9-23"><a href="#cb9-23"></a>      extent<span class="op">=</span>extents(x <span class="op">*</span> w) <span class="op">+</span> extents(y <span class="op">*</span> h),</span>
<span id="cb9-24"><a href="#cb9-24"></a>      origin<span class="op">=</span><span class="st">&#39;lower&#39;</span>)</span>
<span id="cb9-25"><a href="#cb9-25"></a></span>
<span id="cb9-26"><a href="#cb9-26"></a>  fax.imshow(</span>
<span id="cb9-27"><a href="#cb9-27"></a>      np.real(F2cent(arr)),</span>
<span id="cb9-28"><a href="#cb9-28"></a>      aspect<span class="op">=</span><span class="st">&#39;equal&#39;</span>,</span>
<span id="cb9-29"><a href="#cb9-29"></a>      interpolation<span class="op">=</span><span class="st">&#39;none&#39;</span>,</span>
<span id="cb9-30"><a href="#cb9-30"></a>      extent<span class="op">=</span>extents(x) <span class="op">+</span> extents(y),</span>
<span id="cb9-31"><a href="#cb9-31"></a>      origin<span class="op">=</span><span class="st">&#39;lower&#39;</span>)</span>
<span id="cb9-32"><a href="#cb9-32"></a>  sax.grid(<span class="va">False</span>)</span>
<span id="cb9-33"><a href="#cb9-33"></a>  fax.grid(<span class="va">False</span>)</span>
<span id="cb9-34"><a href="#cb9-34"></a>  sax.set_xlabel(<span class="st">&#39;pixel&#39;</span>)</span>
<span id="cb9-35"><a href="#cb9-35"></a>  fax.set_xlabel(<span class="st">&#39;cycles/pixel&#39;</span>)</span>
<span id="cb9-36"><a href="#cb9-36"></a></span>
<span id="cb9-37"><a href="#cb9-37"></a>  <span class="cf">return</span> fig, sax, fax</span>
<span id="cb9-38"><a href="#cb9-38"></a></span>
<span id="cb9-39"><a href="#cb9-39"></a></span>
<span id="cb9-40"><a href="#cb9-40"></a>hplots <span class="op">=</span> plotF2cent(h)</span>
<span id="cb9-41"><a href="#cb9-41"></a>hplots[<span class="dv">1</span>].set_title(<span class="st">&#39;L(r): spatial-domain&#39;</span>)</span>
<span id="cb9-42"><a href="#cb9-42"></a>hplots[<span class="dv">2</span>].set_title(<span class="st">&#39;F[L(r)]: frequency-domain&#39;</span>)</span>
<span id="cb9-43"><a href="#cb9-43"></a>plt.savefig(<span class="st">&#39;full-hankel.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb9-44"><a href="#cb9-44"></a>plt.savefig(<span class="st">&#39;full-hankel.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb9-45"><a href="#cb9-45"></a></span>
<span id="cb9-46"><a href="#cb9-46"></a>actual <span class="op">=</span> np.real(F2cent(h))[<span class="dv">100</span>, :]</span>
<span id="cb9-47"><a href="#cb9-47"></a>f <span class="op">=</span> np.ceil(np.arange(<span class="dv">200</span>) <span class="op">-</span> <span class="dv">200</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">/</span> <span class="dv">200</span></span>
<span id="cb9-48"><a href="#cb9-48"></a>expected <span class="op">=</span> np.<span class="bu">abs</span>(f <span class="op">*</span> <span class="dv">4</span>)<span class="op">**</span>alpha</span>
<span id="cb9-49"><a href="#cb9-49"></a>plt.figure()</span>
<span id="cb9-50"><a href="#cb9-50"></a>plt.plot(f, actual, <span class="st">&#39;-&#39;</span>, f, expected, <span class="st">&#39;--&#39;</span>, f, actual <span class="op">/</span> expected, <span class="st">&#39;.&#39;</span>)</span>
<span id="cb9-51"><a href="#cb9-51"></a>plt.xlabel(<span class="st">&#39;f (cycles/pixel)&#39;</span>)</span>
<span id="cb9-52"><a href="#cb9-52"></a>plt.legend([<span class="st">&#39;actual&#39;</span>, <span class="st">&#39;expected&#39;</span>, <span class="st">&#39;actual/expected&#39;</span>])</span>
<span id="cb9-53"><a href="#cb9-53"></a>plt.title(<span class="st">&#39;Cut of actual F[L(r)] versus expected |4⋅f|^0.8&#39;</span>)</span>
<span id="cb9-54"><a href="#cb9-54"></a>plt.savefig(<span class="st">&#39;full-hankel-actual-expected.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb9-55"><a href="#cb9-55"></a>plt.savefig(<span class="st">&#39;full-hankel-actual-expected.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span></code></pre></div>
<p><img src="full-hankel.png" alt="An array of evaluating the expression we computed for the Fourier transform of the fractional-Laplacian operator, and it&#39;s actual Fourier transform" /></p>
<p>Above: an array of evaluating the expression we computed for the Fourier transform of the fractional-Laplacian operator, and it's actual Fourier transform.</p>
<p><img src="full-hankel-actual-expected.svg" alt="Comparing the actual frequency response of our expression for the spatial-domain equivalent of the fractional-Laplacial, versus the expected frequency response, and their difference, which is approximately 1.024" /></p>
<p>Above: Comparing the actual frequency response of our expression for the spatial-domain equivalent of the fractional-Laplacial, versus the expected frequency response, and their difference, which is approximately 1.024.</p>
<p>This is a success! First, note that the 200×200 array on the left is close to zero: it has a bright center, and decays quickly as the radius from the center–origin grows. Next, note that its 2D Fourier transform is indeed what we had hoped: it sweeps out \(∝|f|^{α=0.8}\) radially, for angular radii between 0 and π radians (normalized here to cycles instead of radians: the axes between ±0.5 cycles per pixel correspond to ±π radians per pixel). (The symbol "\(∝\)" is read as "proportional to".)</p>
<p>The second plot above shows the near-constant ratio between the center-cut through the FFT of the spatial filter \(L(r)\) and a scaled version of what we expect. Comparing \(|4f|^α\), for \(α=0.8\), to the cut through the FFT's output, we see a very-nearly-constant ratio of 1.024. Do note that the actual value inside the absolute value is irrelevant, and amounts only to scaling the texture-shaded output.</p>
<p><strong>However</strong>, we cannot use \(L(r)\) as a spatial-domain equivalent of texture-shading because recall that the original algorithm requires</p>
<p>$$y = F^{-1}[F[x] ⋅ |\vec f|^α],$$ but \(|\vec f|^α\) includes the <em>corners</em> of the frequency domain, not the radial pattern we see from the circular bull's-eye chart above, where the corners in the frequency domain get zero weight. We might use \(L(r)\) nonetheless and accept the infidelity to the texture-shading algorithm, but we don't need to. If we decimate the spatial-domain filter \(L(r)\) by two, then we effectively get the middle-half of its frequency response, which will be \(∝|f|^α\) all the way out to its edges. The Scipy ecosystem provides several ways to <a href="https://docs.scipy.org/doc/scipy/reference/signal.html#filter-design">design halfband filters</a>. A simple example to demonstrate the idea will suffice: design an 8th order low-pass Butterworth filter and apply it along rows and columns of the spatial-domain filter, then downsample the result (throw away every other row/column):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># export math-hankel.py</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="im">import</span> scipy.signal <span class="im">as</span> sig</span>
<span id="cb10-3"><a href="#cb10-3"></a>lpf <span class="op">=</span> sig.iirfilter(<span class="dv">8</span>, <span class="fl">0.5</span>, btype<span class="op">=</span><span class="st">&#39;lowpass&#39;</span>, ftype<span class="op">=</span><span class="st">&#39;butter&#39;</span>)</span>
<span id="cb10-4"><a href="#cb10-4"></a>hiir <span class="op">=</span> sig.filtfilt(<span class="op">*</span>lpf, sig.filtfilt(<span class="op">*</span>lpf, h, axis<span class="op">=</span><span class="dv">0</span>), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a>lpfplots <span class="op">=</span> plotF2cent(hiir)</span>
<span id="cb10-7"><a href="#cb10-7"></a>decplots <span class="op">=</span> plotF2cent(hiir[:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>, :<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>])</span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a>lpfplots[<span class="dv">1</span>].set_title(<span class="st">&#39;LPF[L(r)]&#39;</span>)</span>
<span id="cb10-10"><a href="#cb10-10"></a>lpfplots[<span class="dv">2</span>].set_title(<span class="st">&#39;F[LPF[L(r)]]&#39;</span>)</span>
<span id="cb10-11"><a href="#cb10-11"></a>lpfplots[<span class="dv">0</span>].savefig(<span class="st">&#39;lpf-hankel.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb10-12"><a href="#cb10-12"></a>lpfplots[<span class="dv">0</span>].savefig(<span class="st">&#39;lpf-hankel.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb10-13"><a href="#cb10-13"></a></span>
<span id="cb10-14"><a href="#cb10-14"></a>decplots[<span class="dv">1</span>].set_title(<span class="st">&#39;HB[L(r)]&#39;</span>)</span>
<span id="cb10-15"><a href="#cb10-15"></a>decplots[<span class="dv">2</span>].set_title(<span class="st">&#39;F[HB[L(r)]]&#39;</span>)</span>
<span id="cb10-16"><a href="#cb10-16"></a>decplots[<span class="dv">0</span>].savefig(<span class="st">&#39;hb-hankel.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb10-17"><a href="#cb10-17"></a>decplots[<span class="dv">0</span>].savefig(<span class="st">&#39;hb-hankel.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span></code></pre></div>
<p>The results are positive: while this filtering process can certainly be improved, we have obtained a spatial-domain filter that closely-approximates the fractional-Laplacian frequency-domain operator needed by the texture-shading algorithm.</p>
<p><img src="lpf-hankel.png" alt="Low-pass-filtered version of our initial spatial-domain-created filter" /></p>
<p>Above: low-pass-filtered version of our initial spatial-domain-created filter.</p>
<p><img src="hb-hankel.png" alt="Halfbanded (decimated) version of our initial spatial-dmain-created filter: this meets the requirements of the original texture-shading algorithm" /></p>
<p>Above: halfbanded (decimated) version of our initial spatial-dmain-created filter: this meets the requirements of the original texture-shading algorithm.</p>
<h2 id="a-more-complete-implementation-of-the-approximation">A more complete implementation of the approximation</h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># export hankel.py</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="im">from</span> mpmath <span class="im">import</span> hyper</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="im">from</span> scipy <span class="im">import</span> signal</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="im">from</span> scipy.signal <span class="im">import</span> convolve2d</span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="im">import</span> numpy.fft <span class="im">as</span> fft</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="im">import</span> functools</span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> interp1d</span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="at">@functools.lru_cache</span>(maxsize<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="kw">def</span> spatial(r, a, integralMax<span class="op">=</span>np.pi):</span>
<span id="cb11-13"><a href="#cb11-13"></a>  <span class="co"># Wolfram Alpha: `2*pi*Integrate[f^a * BesselJ[0, k * f] * f, f, 0, m]`</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>  <span class="cf">return</span> <span class="bu">float</span>(hyper((<span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">1</span>,), (<span class="fl">1.0</span>, <span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">2</span>), <span class="fl">-0.25</span> <span class="op">*</span> (r <span class="op">*</span> integralMax)<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb11-15"><a href="#cb11-15"></a></span>
<span id="cb11-16"><a href="#cb11-16"></a></span>
<span id="cb11-17"><a href="#cb11-17"></a><span class="kw">def</span> vec(v):</span>
<span id="cb11-18"><a href="#cb11-18"></a>  <span class="cf">return</span> v.reshape(v.size, <span class="dv">-1</span>)</span>
<span id="cb11-19"><a href="#cb11-19"></a></span>
<span id="cb11-20"><a href="#cb11-20"></a></span>
<span id="cb11-21"><a href="#cb11-21"></a><span class="kw">def</span> fullHankel(n, alpha, interpMethod<span class="op">=</span><span class="va">True</span>, sampleSpacing<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb11-22"><a href="#cb11-22"></a>  rvec <span class="op">=</span> np.arange(<span class="op">-</span>n, n)</span>
<span id="cb11-23"><a href="#cb11-23"></a>  rmat <span class="op">=</span> np.sqrt(vec(rvec)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> vec(rvec).T<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb11-24"><a href="#cb11-24"></a></span>
<span id="cb11-25"><a href="#cb11-25"></a>  <span class="cf">if</span> interpMethod:</span>
<span id="cb11-26"><a href="#cb11-26"></a>    <span class="cf">if</span> <span class="kw">not</span> sampleSpacing:</span>
<span id="cb11-27"><a href="#cb11-27"></a>      sampleSpacing <span class="op">=</span> <span class="fl">1e-2</span></span>
<span id="cb11-28"><a href="#cb11-28"></a>    data <span class="op">=</span> precomputeLoad(alpha, np.ceil(np.sqrt(<span class="dv">2</span>) <span class="op">*</span> n <span class="op">*</span> <span class="fl">1.01</span>), sampleSpacing)</span>
<span id="cb11-29"><a href="#cb11-29"></a>    oned <span class="op">=</span> interp1d(data[<span class="st">&#39;r&#39;</span>], data[<span class="st">&#39;h&#39;</span>])</span>
<span id="cb11-30"><a href="#cb11-30"></a>    hmat <span class="op">=</span> oned(rmat)</span>
<span id="cb11-31"><a href="#cb11-31"></a>  <span class="cf">else</span>:</span>
<span id="cb11-32"><a href="#cb11-32"></a>    fun <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x: spatial(x, alpha))</span>
<span id="cb11-33"><a href="#cb11-33"></a>    hmat <span class="op">=</span> fun(rmat)</span>
<span id="cb11-34"><a href="#cb11-34"></a>  <span class="cf">return</span> hmat</span>
<span id="cb11-35"><a href="#cb11-35"></a></span>
<span id="cb11-36"><a href="#cb11-36"></a></span>
<span id="cb11-37"><a href="#cb11-37"></a><span class="kw">def</span> design(N<span class="op">=</span><span class="dv">32</span>, passbandWidth<span class="op">=</span><span class="fl">0.03</span>):</span>
<span id="cb11-38"><a href="#cb11-38"></a>  <span class="cf">if</span> N <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb11-39"><a href="#cb11-39"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;N must be even&#39;</span>)</span>
<span id="cb11-40"><a href="#cb11-40"></a>  <span class="cf">if</span> N <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb11-41"><a href="#cb11-41"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;N must be &gt; 1&#39;</span>)</span>
<span id="cb11-42"><a href="#cb11-42"></a>  <span class="cf">if</span> <span class="kw">not</span> (passbandWidth <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> passbandWidth <span class="op">&lt;</span> <span class="fl">0.5</span>):</span>
<span id="cb11-43"><a href="#cb11-43"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;Need 0 &lt; passbandWidth &lt; 0.5&#39;</span>)</span>
<span id="cb11-44"><a href="#cb11-44"></a>  bands <span class="op">=</span> np.array([<span class="fl">0.</span>, <span class="fl">.25</span> <span class="op">-</span> passbandWidth, <span class="fl">.25</span> <span class="op">+</span> passbandWidth, <span class="fl">.5</span>])</span>
<span id="cb11-45"><a href="#cb11-45"></a>  h <span class="op">=</span> signal.remez(N <span class="op">+</span> <span class="dv">1</span>, bands, [<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">1</span>])</span>
<span id="cb11-46"><a href="#cb11-46"></a>  h[<span class="bu">abs</span>(h) <span class="op">&lt;=</span> <span class="fl">1e-4</span>] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb11-47"><a href="#cb11-47"></a>  <span class="cf">return</span> h</span>
<span id="cb11-48"><a href="#cb11-48"></a></span>
<span id="cb11-49"><a href="#cb11-49"></a></span>
<span id="cb11-50"><a href="#cb11-50"></a><span class="kw">def</span> halfband(hmat, taps<span class="op">=</span><span class="dv">32</span>):</span>
<span id="cb11-51"><a href="#cb11-51"></a>  hbFilter <span class="op">=</span> design(taps)</span>
<span id="cb11-52"><a href="#cb11-52"></a>  doubleFilter <span class="op">=</span> convolve2d(</span>
<span id="cb11-53"><a href="#cb11-53"></a>      convolve2d(hmat, vec(hbFilter), mode<span class="op">=</span><span class="st">&#39;same&#39;</span>), vec(hbFilter).T, mode<span class="op">=</span><span class="st">&#39;same&#39;</span>)</span>
<span id="cb11-54"><a href="#cb11-54"></a>  n <span class="op">=</span> hmat.shape[<span class="dv">0</span>]</span>
<span id="cb11-55"><a href="#cb11-55"></a>  finalFilter <span class="op">=</span> doubleFilter[:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>, :<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>] <span class="cf">if</span> n <span class="op">%</span> <span class="dv">4</span> <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> doubleFilter[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>]</span>
<span id="cb11-56"><a href="#cb11-56"></a>  <span class="cf">return</span> finalFilter</span>
<span id="cb11-57"><a href="#cb11-57"></a></span>
<span id="cb11-58"><a href="#cb11-58"></a></span>
<span id="cb11-59"><a href="#cb11-59"></a><span class="kw">def</span> precomputeLoad(alpha, N, spacing):</span>
<span id="cb11-60"><a href="#cb11-60"></a>  <span class="im">import</span> os.path</span>
<span id="cb11-61"><a href="#cb11-61"></a>  fun <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x: spatial(x, alpha))</span>
<span id="cb11-62"><a href="#cb11-62"></a>  r <span class="op">=</span> np.arange(<span class="dv">0</span>, N, spacing)</span>
<span id="cb11-63"><a href="#cb11-63"></a>  fname <span class="op">=</span> <span class="st">&#39;hankel-alpha-</span><span class="sc">{}</span><span class="st">&#39;</span>.<span class="bu">format</span>(alpha)</span>
<span id="cb11-64"><a href="#cb11-64"></a>  <span class="cf">if</span> os.path.isfile(fname <span class="op">+</span> <span class="st">&#39;.npz&#39;</span>):</span>
<span id="cb11-65"><a href="#cb11-65"></a>    npz <span class="op">=</span> np.load(fname <span class="op">+</span> <span class="st">&#39;.npz&#39;</span>)</span>
<span id="cb11-66"><a href="#cb11-66"></a>    rsave <span class="op">=</span> npz[<span class="st">&#39;x&#39;</span>]</span>
<span id="cb11-67"><a href="#cb11-67"></a>    hsave <span class="op">=</span> npz[<span class="st">&#39;y&#39;</span>]</span>
<span id="cb11-68"><a href="#cb11-68"></a></span>
<span id="cb11-69"><a href="#cb11-69"></a>    rnew <span class="op">=</span> np.sort(np.setdiff1d(r, rsave))</span>
<span id="cb11-70"><a href="#cb11-70"></a>    hnew <span class="op">=</span> fun(rnew) <span class="cf">if</span> rnew.size <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> []</span>
<span id="cb11-71"><a href="#cb11-71"></a></span>
<span id="cb11-72"><a href="#cb11-72"></a>    r <span class="op">=</span> np.hstack([rsave, rnew])</span>
<span id="cb11-73"><a href="#cb11-73"></a>    h <span class="op">=</span> np.hstack([hsave, hnew])</span>
<span id="cb11-74"><a href="#cb11-74"></a>    idx <span class="op">=</span> np.argsort(r)  <span class="co"># wasteful but resorting 1k vec is fast</span></span>
<span id="cb11-75"><a href="#cb11-75"></a>    r <span class="op">=</span> r[idx]</span>
<span id="cb11-76"><a href="#cb11-76"></a>    h <span class="op">=</span> h[idx]</span>
<span id="cb11-77"><a href="#cb11-77"></a>  <span class="cf">else</span>:</span>
<span id="cb11-78"><a href="#cb11-78"></a>    h <span class="op">=</span> fun(r)</span>
<span id="cb11-79"><a href="#cb11-79"></a>  np.savez(fname, x<span class="op">=</span>r, y<span class="op">=</span>h)</span>
<span id="cb11-80"><a href="#cb11-80"></a>  <span class="cf">return</span> <span class="bu">dict</span>(r<span class="op">=</span>r, h<span class="op">=</span>h)</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># export hankel-demo.py</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="im">import</span> hankel</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="im">import</span> texshade</span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="im">import</span> postprocess</span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="im">from</span> scipy.signal <span class="im">import</span> fftconvolve</span>
<span id="cb12-7"><a href="#cb12-7"></a>nextpow2 <span class="op">=</span> <span class="kw">lambda</span> v: <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="dv">2</span><span class="op">**</span>np.ceil(np.log2(v))))</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif.npy&#39;</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>arr <span class="op">=</span> np.load(fname)</span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a>clip <span class="op">=</span> <span class="va">True</span></span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="cf">if</span> clip:</span>
<span id="cb12-14"><a href="#cb12-14"></a>  arr <span class="op">=</span> arr[<span class="op">-</span><span class="dv">1500</span>:, <span class="dv">-1500</span>:]</span>
<span id="cb12-15"><a href="#cb12-15"></a></span>
<span id="cb12-16"><a href="#cb12-16"></a></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="kw">def</span> texToFile(tex, fname):</span>
<span id="cb12-18"><a href="#cb12-18"></a>  minmax <span class="op">=</span> np.quantile(tex.ravel(), [.<span class="dv">01</span>, <span class="fl">.99</span>])</span>
<span id="cb12-19"><a href="#cb12-19"></a>  scaled <span class="op">=</span> postprocess.touint(tex, minmax[<span class="dv">0</span>], minmax[<span class="dv">1</span>], np.uint8)</span>
<span id="cb12-20"><a href="#cb12-20"></a>  postprocess.toPng(scaled, fname)</span>
<span id="cb12-21"><a href="#cb12-21"></a></span>
<span id="cb12-22"><a href="#cb12-22"></a></span>
<span id="cb12-23"><a href="#cb12-23"></a>alpha <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb12-24"><a href="#cb12-24"></a></span>
<span id="cb12-25"><a href="#cb12-25"></a>texToFile(</span>
<span id="cb12-26"><a href="#cb12-26"></a>    texshade.texshade(arr, alpha),</span>
<span id="cb12-27"><a href="#cb12-27"></a>    <span class="st">&#39;orig-texshade-alpha-</span><span class="sc">{}{}</span><span class="st">.png&#39;</span>.<span class="bu">format</span>(alpha, <span class="st">&#39;-clip&#39;</span> <span class="cf">if</span> clip <span class="cf">else</span> <span class="st">&#39;&#39;</span>))</span>
<span id="cb12-28"><a href="#cb12-28"></a></span>
<span id="cb12-29"><a href="#cb12-29"></a>Nwidth <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb12-30"><a href="#cb12-30"></a>Nhalfband <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb12-31"><a href="#cb12-31"></a></span>
<span id="cb12-32"><a href="#cb12-32"></a>h <span class="op">=</span> hankel.halfband(hankel.fullHankel(Nwidth, alpha), Nhalfband)</span>
<span id="cb12-33"><a href="#cb12-33"></a>texToFile(</span>
<span id="cb12-34"><a href="#cb12-34"></a>    fftconvolve(arr, h, mode<span class="op">=</span><span class="st">&#39;same&#39;</span>),</span>
<span id="cb12-35"><a href="#cb12-35"></a>    <span class="st">&#39;hankel-texshade-alpha-</span><span class="sc">{}</span><span class="st">-n-</span><span class="sc">{}{}</span><span class="st">.png&#39;</span>.<span class="bu">format</span>(alpha, Nwidth, <span class="st">&#39;-clip&#39;</span> <span class="cf">if</span> clip <span class="cf">else</span> <span class="st">&#39;&#39;</span>))</span>
<span id="cb12-36"><a href="#cb12-36"></a></span>
<span id="cb12-37"><a href="#cb12-37"></a>hFull <span class="op">=</span> hankel.fullHankel(Nwidth, alpha)</span>
<span id="cb12-38"><a href="#cb12-38"></a>texToFile(</span>
<span id="cb12-39"><a href="#cb12-39"></a>    fftconvolve(arr, hFull, mode<span class="op">=</span><span class="st">&#39;same&#39;</span>),</span>
<span id="cb12-40"><a href="#cb12-40"></a>    <span class="st">&#39;hankel-texshadeFullband-alpha-</span><span class="sc">{}</span><span class="st">-n-</span><span class="sc">{}{}</span><span class="st">.png&#39;</span>.<span class="bu">format</span>(alpha, Nwidth, <span class="st">&#39;-clip&#39;</span> <span class="cf">if</span> clip <span class="cf">else</span> <span class="st">&#39;&#39;</span>))</span></code></pre></div>
<p>We can compare the output of the original texture-shading algorithm:</p>
<p><img src="orig-texshade-alpha-0.8-clip.png" alt="Texshaded clip" /></p>
<p>with that of the Hankel approximation:</p>
<p><img src="hankel-texshade-alpha-0.8-n-500-clip.png" alt="Hankel-approximated texshaded clip" /></p>
<p>Both are very close. Toggling between them only reveals slight contrast differences due to the different levels obtained for the quantiles—these differences are likely caused by the artifacts at the edges.</p>
<p>In the above demo code, we ask Scipy's <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.fftconvolve.html"><code>fftconvolve</code></a> to apply the spatial-domain filtering, which behind the scenes uses a full-sized FFT just like the original method. However, we can make this much more memory-efficient, while retaining its speed, by using the overlap-add (or overlap-save) technique of fast-convolution.</p>
<h2 id="overlap-save-method-for-fast-convolution">Overlap-save method for fast-convolution</h2>
<p>The textbook definition of convolving two signals in the spatial domain is a quadratic \(O(N^2)\) operation. Since convolution in the spatial domain is mathematically equivalent to multiplication in the frequency domain, and the FFT is a log-linear \(O(N \log N)\) operation, this is usually much faster—this is why we use <code>fftconvolve</code> above. The drawback of the FFT-based alternative to direct convolution is that it requires we run the FFT on the signals of interest—with a potentially prohibitive memory burden.</p>
<p>The overlap-save method (and its closely-related sibling, the overlap-add method) allow us to convolve signals more intelligently: it still uses FFTs, so the overall theoretical runtime complexity remains log-linear, but it uses <em>many small</em> FFTs so memory consumption remains reasonable. I prefer overlap-save because it partitions the <em>output</em> array into non-overlapping segments that each step of the algorithm fills in (and which may be parallelized). Each step of the overlap-save algorithm reaches for segments of <em>input</em> that may overlap with other steps, but this overlap is read-only.</p>
<blockquote>
<p>In contrast, overlap-add splits the <em>input</em> array into non-overlapping segments. Each step of that algorithm has to potentially modify previously-computed samples of the <em>output</em>, which makes parallelization much more nasty (requiring locks or careful orchestration of the sequence of steps).</p>
</blockquote>
<p>The overlap-save implementation I wrote is largely out of the scope of this texture-shading library, so let's just import it and show how we can use it, along with memory-mapped inputs and outputs to <em>really</em> save memory.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># export hankel-memmap.py</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="im">import</span> hankel</span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="im">import</span> postprocess</span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="im">from</span> ols <span class="im">import</span> ols</span>
<span id="cb13-6"><a href="#cb13-6"></a></span>
<span id="cb13-7"><a href="#cb13-7"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif.npy&#39;</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>arr <span class="op">=</span> np.load(fname, mmap_mode<span class="op">=</span><span class="st">&#39;r&#39;</span>)</span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="kw">def</span> texToFile(tex, fname):</span>
<span id="cb13-12"><a href="#cb13-12"></a>  minmax <span class="op">=</span> np.quantile(tex.ravel(), [.<span class="dv">01</span>, <span class="fl">.99</span>])</span>
<span id="cb13-13"><a href="#cb13-13"></a>  scaled <span class="op">=</span> postprocess.touint(tex, minmax[<span class="dv">0</span>], minmax[<span class="dv">1</span>], np.uint8)</span>
<span id="cb13-14"><a href="#cb13-14"></a>  postprocess.toPng(scaled, fname)</span>
<span id="cb13-15"><a href="#cb13-15"></a></span>
<span id="cb13-16"><a href="#cb13-16"></a></span>
<span id="cb13-17"><a href="#cb13-17"></a>alpha <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb13-18"><a href="#cb13-18"></a></span>
<span id="cb13-19"><a href="#cb13-19"></a>Nwidth <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb13-20"><a href="#cb13-20"></a>Nhalfband <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb13-21"><a href="#cb13-21"></a>h <span class="op">=</span> hankel.halfband(hankel.fullHankel(Nwidth, alpha), Nhalfband)</span>
<span id="cb13-22"><a href="#cb13-22"></a></span>
<span id="cb13-23"><a href="#cb13-23"></a>tex <span class="op">=</span> np.lib.<span class="bu">format</span>.open_memmap(<span class="st">&#39;mmap-tex.npy&#39;</span>, mode<span class="op">=</span><span class="st">&#39;w+&#39;</span>, dtype<span class="op">=</span>np.float64, shape<span class="op">=</span>arr.shape)</span>
<span id="cb13-24"><a href="#cb13-24"></a>ols(arr, h, size<span class="op">=</span>[<span class="dv">2000</span>, <span class="dv">2000</span>], out<span class="op">=</span>tex)</span>
<span id="cb13-25"><a href="#cb13-25"></a>texToFile(tex, <span class="st">&#39;hankel-texshade-alpha-</span><span class="sc">{}</span><span class="st">-n-</span><span class="sc">{}</span><span class="st">-mmap.png&#39;</span>.<span class="bu">format</span>(alpha, Nwidth))</span></code></pre></div>
<p>To downsample this large image for including with this repo:</p>
<pre><code>convert -filter Mitchell -sampling-factor 1x1 -quality 90 -resize 2048 hankel-texshade-alpha-0.8-n-500-mmap.png hankel-texshade-alpha-0.8-n-500-mmap.png.small.png</code></pre>
<p><img src="hankel-texshade-alpha-0.8-n-500-mmap.png.small.png" alt="Memory-efficient tex-shading via memory-mapped files and overlap-save technique of fast convolution" /></p>
<p>This image is qualitatively identical to the original texture-shaded output <a href="#tex-shaded">previously shown</a> but to reemphasize: while the <a href="#tex-shaded">original</a> texture-shaded image involved slurping the entire dataset into memory, and then computing huge FFTs of it, the image just above, generated by the <code>hankel-memmap.py</code> script, sipped memory: it loaded the input array as a memory-mapped file, allocated the output as a memory-mapped file, and used a spatial-domain filter to approximate the frequency-domain operator in the original image. By using the overlap-save method of fast-convolution, the filter was applied on small chunks of the data.</p>
<p>We can finally run the texture-shading algorithm on enormous datasets without needing gargantuan amounts of memory.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>John Otander's <a href="http://markdowncss.github.io/retro/">Retro</a> CSS theme. KaTeX for rendering equations.</p>
