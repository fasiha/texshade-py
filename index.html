<!DOCTYPE html>

<head>
  <meta charset="utf-8">
  <title>Texshade: texture-shaded elevation via the fractional-Laplacian operator</title>
  <link rel="stylesheet" href="assets/retro.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css"
    integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js"
    integrity="sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1"
    crossorigin="anonymous"></script>

  <!-- To automatically render math in text elements, include the auto-render extension: -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js"
    integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters: [
      {left: '$$', right: '$$', display: true},
    {left: '\\(', right: '\\)', display: false}
]});"></script>

  <script>
    window.WebFontConfig = {
      custom: {
        families: ['KaTeX_AMS', 'KaTeX_Caligraphic:n4,n7', 'KaTeX_Fraktur:n4,n7',
          'KaTeX_Main:n4,n7,i4,i7', 'KaTeX_Math:i4,i7', 'KaTeX_Script',
          'KaTeX_SansSerif:n4,n7,i4', 'KaTeX_Size1', 'KaTeX_Size2', 'KaTeX_Size3',
          'KaTeX_Size4', 'KaTeX_Typewriter'],
      },
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js"
    integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script>

  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }
  </style>
  <style>
    <style>code.sourceCode>span {
      display: inline-block;
      line-height: 1.25;
    }

    code.sourceCode>span {
      color: inherit;
      text-decoration: inherit;
    }

    code.sourceCode>span:empty {
      height: 1.2em;
    }

    .sourceCode {
      overflow: visible;
    }

    code.sourceCode {
      white-space: pre;
      position: relative;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      code.sourceCode {
        white-space: pre-wrap;
      }

      code.sourceCode>span {
        text-indent: -5em;
        padding-left: 5em;
      }
    }

    pre.numberSource code {
      counter-reset: source-line 0;
    }

    pre.numberSource code>span {
      position: relative;
      left: -4em;
      counter-increment: source-line;
    }

    pre.numberSource code>span>a:first-child::before {
      content: counter(source-line);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
      background-color: #232629;
      color: #7a7c7d;
    }

    pre.numberSource {
      margin-left: 3em;
      border-left: 1px solid #7a7c7d;
      padding-left: 4px;
    }

    div.sourceCode {
      color: #cfcfc2;
      background-color: #232629;
    }

    @media screen {
      code.sourceCode>span>a:first-child::before {
        text-decoration: underline;
      }
    }

    code span. {
      color: #cfcfc2;
    }

    /* Normal */
    code span.al {
      color: #95da4c;
    }

    /* Alert */
    code span.an {
      color: #3f8058;
    }

    /* Annotation */
    code span.at {
      color: #2980b9;
    }

    /* Attribute */
    code span.bn {
      color: #f67400;
    }

    /* BaseN */
    code span.bu {
      color: #7f8c8d;
    }

    /* BuiltIn */
    code span.cf {
      color: #fdbc4b;
    }

    /* ControlFlow */
    code span.ch {
      color: #3daee9;
    }

    /* Char */
    code span.cn {
      color: #27aeae;
    }

    /* Constant */
    code span.co {
      color: #7a7c7d;
    }

    /* Comment */
    code span.cv {
      color: #7f8c8d;
    }

    /* CommentVar */
    code span.do {
      color: #a43340;
    }

    /* Documentation */
    code span.dt {
      color: #2980b9;
    }

    /* DataType */
    code span.dv {
      color: #f67400;
    }

    /* DecVal */
    code span.er {
      color: #da4453;
    }

    /* Error */
    code span.ex {
      color: #0099ff;
    }

    /* Extension */
    code span.fl {
      color: #f67400;
    }

    /* Float */
    code span.fu {
      color: #8e44ad;
    }

    /* Function */
    code span.im {
      color: #27ae60;
    }

    /* Import */
    code span.in {
      color: #c45b00;
    }

    /* Information */
    code span.kw {
      color: #cfcfc2;
    }

    /* Keyword */
    code span.op {
      color: #cfcfc2;
    }

    /* Operator */
    code span.ot {
      color: #27ae60;
    }

    /* Other */
    code span.pp {
      color: #27ae60;
    }

    /* Preprocessor */
    code span.re {
      color: #2980b9;
    }

    /* RegionMarker */
    code span.sc {
      color: #3daee9;
    }

    /* SpecialChar */
    code span.ss {
      color: #da4453;
    }

    /* SpecialString */
    code span.st {
      color: #f44f4f;
    }

    /* String */
    code span.va {
      color: #27aeae;
    }

    /* Variable */
    code span.vs {
      color: #da4453;
    }

    /* VerbatimString */
    code span.wa {
      color: #da4453;
    }

    /* Warning */
  </style>

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->

</head><h1 id="texshade-texture-shaded-elevation-via-the-fractional-laplacian-operator">Texshade: texture-shaded elevation via the fractional-Laplacian operator</h1>
<h2 id="introduction">Introduction</h2>
<p>See <a href="http://www.textureshading.com/Home.html" class="uri">http://www.textureshading.com/Home.html</a> for links to papers and slides by Leland Brown from 2010 and 2014 describing the technique of texture shading, but in summary, it is a method of processing digital elevation maps (DEMs) that highlights the network nature of topography, throwing ridges, canyons, and valleys into sharp relief.</p>
<p>This repository contains an open-source public-domain Python/Numpy software library to apply the texture shading algorithm on <em>extremely</em> large datasets. This is a challenge because a straightforward implementation of the texture-shading technique requires loading the entire elevation map into memory. For large datasets—like the ASTER Global DEM, which comes in at roughly 250 GB compressed—you either have to find a computer with a lot of memory (nodes with 1 TB RAM are available at many scientific organizations as of 2018) or you have to modify the technique.</p>
<p>This repository contains (1) mathematical and (2) software details of a low-memory approximation to the original texture-shading algorithm that in practice produces texture-shaded imagery very similar to the full algorithm.</p>
<p>The mathematical trick, in a nutshell, is to use the Hankel transform to find a finite impulse response (FIR) filter that approximates the frequency-domain fractional-Laplacian operator, and apply that filter in the spatial domain via the efficient overlap-save algorithm. According to GitHub commit logs, I first derived this technique in 2015.</p>
<h2 id="installation-and-usage">Installation and usage</h2>
<pre><code>$ pip install texshade</code></pre>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">import</span> texshade</span></code></pre></div>
<h2 id="the-texture-shading-algorithm">The texture-shading algorithm</h2>
<p>The original texture-shading algorithm takes a 2D array of elevations, call it \(x\), and computes the texture-shaded elevation map,</p>
<p>$$y = F^{-1}[F[x] ⋅ |\vec f|^α],$$</p>
<p>where</p>
<ul>
<li>\(F[\cdot]\) is the 2D Fourier transform operator and \(F^{-1}[\cdot]\) its inverse</li>
<li>\(\vec f = [f_x, f_y]'\) the 2D vector of Fourier coordinates, so \(|\vec f|^α=(f_x^2 + f_y^2)^{α/2}\)</li>
<li>\(()'\) indicates matrix or vector transpose</li>
<li>\(0&lt;α≤1\), the "fraction" in the fractional-Laplacian (though Brown gives examples of \(α≤2\)!).</li>
</ul>
<p>While many details of the algorithm have yet to be specified, the output array \(y\) can be made to have the same size as the input \(x\).</p>
<p>Let's implement this in Python.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># export texshade/texshade.py</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="im">import</span> scipy.fftpack <span class="im">as</span> scifft</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="im">from</span> nextprod <span class="im">import</span> nextprod</span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">def</span> texshadeFFT(x, alpha, verbose<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb3-8"><a href="#cb3-8"></a>  <span class="co">&quot;&quot;&quot;FFT-based texture-shading elevation</span></span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="co">  Given an array `x` of elevation data and an `alpha` &gt; 0, apply the</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co">  texture-shading algorithm using the full (real-only) FFT: the entire `x` array</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">  will be FFT&#39;d.</span></span>
<span id="cb3-13"><a href="#cb3-13"></a></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">  `alpha` is the shading detail factor, i.e., the power of the</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">  fractional-Laplacian operator. `alpha=0` means no detail (output is the</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="co">  input). `alpha=2.0` is the full (non-fractional) Laplacian operator and is</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="co">  probably too high. `alpha &lt;= 1.0` seem aesthetically pleasing.</span></span>
<span id="cb3-18"><a href="#cb3-18"></a></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="co">  Returns an array the same dimensions as `x` that contains the texture-shaded</span></span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="co">  version of the input array.</span></span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>  Nyx <span class="op">=</span> [nextprod([<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>], x) <span class="cf">for</span> x <span class="kw">in</span> x.shape]</span>
<span id="cb3-23"><a href="#cb3-23"></a></span>
<span id="cb3-24"><a href="#cb3-24"></a>  fy <span class="op">=</span> scifft.rfftfreq(Nyx[<span class="dv">0</span>])[:, np.newaxis].astype(x.dtype)</span>
<span id="cb3-25"><a href="#cb3-25"></a>  fx <span class="op">=</span> scifft.rfftfreq(Nyx[<span class="dv">1</span>])[np.newaxis, :].astype(x.dtype)</span>
<span id="cb3-26"><a href="#cb3-26"></a>  H2 <span class="op">=</span> (fx<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> fy<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span>(alpha <span class="op">/</span> <span class="fl">2.0</span>)</span>
<span id="cb3-27"><a href="#cb3-27"></a>  <span class="cf">if</span> verbose:</span>
<span id="cb3-28"><a href="#cb3-28"></a>    <span class="bu">print</span>(<span class="st">&quot;Generated filter&quot;</span>)</span>
<span id="cb3-29"><a href="#cb3-29"></a></span>
<span id="cb3-30"><a href="#cb3-30"></a>  rfft2 <span class="op">=</span> <span class="kw">lambda</span> x: scifft.rfft(scifft.rfft(x, Nyx[<span class="dv">1</span>], <span class="dv">1</span>, <span class="va">True</span>), Nyx[<span class="dv">0</span>], <span class="dv">0</span>, <span class="va">True</span>)</span>
<span id="cb3-31"><a href="#cb3-31"></a>  irfft2 <span class="op">=</span> <span class="kw">lambda</span> X: scifft.irfft(scifft.irfft(X, axis<span class="op">=</span><span class="dv">0</span>, overwrite_x<span class="op">=</span><span class="va">True</span>), overwrite_x<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-32"><a href="#cb3-32"></a></span>
<span id="cb3-33"><a href="#cb3-33"></a>  xr <span class="op">=</span> rfft2(x) <span class="op">*</span> H2</span>
<span id="cb3-34"><a href="#cb3-34"></a>  <span class="cf">if</span> verbose:</span>
<span id="cb3-35"><a href="#cb3-35"></a>    <span class="bu">print</span>(<span class="st">&quot;Completed frequency domain operations&quot;</span>)</span>
<span id="cb3-36"><a href="#cb3-36"></a>  H2 <span class="op">=</span> <span class="va">None</span>  <span class="co"># potentially trigger GC here to reclaim H2&#39;s memory</span></span>
<span id="cb3-37"><a href="#cb3-37"></a>  xr <span class="op">=</span> irfft2(xr)</span>
<span id="cb3-38"><a href="#cb3-38"></a>  <span class="cf">if</span> verbose:</span>
<span id="cb3-39"><a href="#cb3-39"></a>    <span class="bu">print</span>(<span class="st">&quot;Back to spatial-domain&quot;</span>)</span>
<span id="cb3-40"><a href="#cb3-40"></a></span>
<span id="cb3-41"><a href="#cb3-41"></a>  <span class="cf">return</span> xr[:x.shape[<span class="dv">0</span>], :x.shape[<span class="dv">1</span>]]</span></code></pre></div>
<h2 id="test-setup">Test setup</h2>
<p>I've downloaded three tiles from the SRTM DEM (from <a href="https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/">this page at SDSC.edu</a>) on the African coastline near 0° N and 0° W and merged them into a single raster using <a href="https://gdal.org/">GDAL</a>, which I installed using <a href="https://formulae.brew.sh/formula/gdal">Brew</a>: installing these is outside the scope of this document, but any DEM you have can be used.</p>
<pre><code>wget https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/N00E009.hgt \
  https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/N00E010.hgt \
  https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTM_GL1/SRTM_GL1_srtm/North/North_0_29/N00E011.hgt
gdalwarp -of GTiff N00E009.hgt N00E010.hgt N00E011.hgt merged.tif</code></pre>
<p>Running <code>gdalinfo merged.tif</code> produces the following output:</p>
<pre><code>Driver: GTiff/GeoTIFF
Files: merged.tif
Size is 10801, 3601
Coordinate System is:
GEOGCS[&quot;WGS 84&quot;,
    DATUM[&quot;WGS_1984&quot;,
        SPHEROID[&quot;WGS 84&quot;,6378137,298.257223563,
            AUTHORITY[&quot;EPSG&quot;,&quot;7030&quot;]],
        AUTHORITY[&quot;EPSG&quot;,&quot;6326&quot;]],
    PRIMEM[&quot;Greenwich&quot;,0],
    UNIT[&quot;degree&quot;,0.0174532925199433],
    AUTHORITY[&quot;EPSG&quot;,&quot;4326&quot;]]
Origin = (8.999861111111111,1.000138888888889)
Pixel Size = (0.000277777777778,-0.000277777777778)
Metadata:
  AREA_OR_POINT=Point
Image Structure Metadata:
  INTERLEAVE=BAND
Corner Coordinates:
Upper Left  (   8.9998611,   1.0001389) (  8d59&#39;59.50&quot;E,  1d 0&#39; 0.50&quot;N)
Lower Left  (   8.9998611,  -0.0001389) (  8d59&#39;59.50&quot;E,  0d 0&#39; 0.50&quot;S)
Upper Right (  12.0001389,   1.0001389) ( 12d 0&#39; 0.50&quot;E,  1d 0&#39; 0.50&quot;N)
Lower Right (  12.0001389,  -0.0001389) ( 12d 0&#39; 0.50&quot;E,  0d 0&#39; 0.50&quot;S)
Center      (  10.5000000,   0.5000000) ( 10d30&#39; 0.00&quot;E,  0d30&#39; 0.00&quot;N)
Band 1 Block=10801x1 Type=Int16, ColorInterp=Gray
  NoData Value=-32768
  Unit Type: m</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># export convert.py</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">Quick script intended to be used only by a user to convert a specific</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">GeoTIF to a NPY file for pure-Numpy non-GDAL demo.</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="im">import</span> gdal, gdalconst</span>
<span id="cb6-8"><a href="#cb6-8"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif&#39;</span></span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="kw">def</span> filenameToData(fname, dtype<span class="op">=</span>np.float32):</span>
<span id="cb6-12"><a href="#cb6-12"></a>  <span class="co">&quot;&quot;&quot;Reads all bands&quot;&quot;&quot;</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>  fileHandle <span class="op">=</span> gdal.Open(fname, gdalconst.GA_ReadOnly)</span>
<span id="cb6-14"><a href="#cb6-14"></a>  result <span class="op">=</span> np.squeeze(</span>
<span id="cb6-15"><a href="#cb6-15"></a>      np.dstack(</span>
<span id="cb6-16"><a href="#cb6-16"></a>          [fileHandle.GetRasterBand(n <span class="op">+</span> <span class="dv">1</span>).ReadAsArray() <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(fileHandle.RasterCount)]))</span>
<span id="cb6-17"><a href="#cb6-17"></a>  <span class="cf">if</span> dtype <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb6-18"><a href="#cb6-18"></a>    <span class="cf">return</span> result.astype(dtype)</span>
<span id="cb6-19"><a href="#cb6-19"></a>  <span class="cf">return</span> result</span>
<span id="cb6-20"><a href="#cb6-20"></a></span>
<span id="cb6-21"><a href="#cb6-21"></a></span>
<span id="cb6-22"><a href="#cb6-22"></a>np.save(fname, filenameToData(fname))</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># export demo.py</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="im">import</span> texshade</span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-4"><a href="#cb7-4"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif.npy&#39;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a>arr <span class="op">=</span> np.load(fname)</span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="bu">print</span>(arr)</span>
<span id="cb7-8"><a href="#cb7-8"></a>tex <span class="op">=</span> texshade.texshadeFFT(arr, <span class="fl">0.8</span>)</span>
<span id="cb7-9"><a href="#cb7-9"></a>np.save(fname <span class="op">+</span> <span class="st">&#39;.tex&#39;</span>, tex)</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># export postprocess.py</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">def</span> touint(x, cmin, cmax, dtype<span class="op">=</span>np.uint8):</span>
<span id="cb8-6"><a href="#cb8-6"></a>  <span class="co">&quot;&quot;&quot;Convert an array to an array of unsigned integers by clamping and scaling</span></span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co">  Given an array of numbers `x`, and the desired min and max values, `cmin` and</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="co">  `cmax` respectively, and optionally a `dtype` that defaults to `uint8`, clamp</span></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">  the values of `x` to between `cmin` and `cmax` (i.e., if a pixel is less than</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="co">  `cmin`, it will be treated as being equal to `cmin`) and scale the values</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="co">  linearly to the full range supported by `dtype`. When `dtype` is `np.uint8`,</span></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="co">  e.g., the output will have values between 0 (originally `cmin`) and 255</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="co">  (originally `cmax`).</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>  <span class="co"># clamp x between cmin and cmax</span></span>
<span id="cb8-17"><a href="#cb8-17"></a>  x[x <span class="op">&lt;</span> cmin] <span class="op">=</span> cmin</span>
<span id="cb8-18"><a href="#cb8-18"></a>  x[x <span class="op">&gt;</span> cmax] <span class="op">=</span> cmax</span>
<span id="cb8-19"><a href="#cb8-19"></a>  <span class="co"># map [cmin, cmax] to [0, 2**depth-1-eps] linearly</span></span>
<span id="cb8-20"><a href="#cb8-20"></a>  maxval <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">8</span> <span class="op">*</span> dtype().itemsize) <span class="op">-</span> <span class="fl">1e-3</span></span>
<span id="cb8-21"><a href="#cb8-21"></a>  slope <span class="op">=</span> (maxval <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">/</span> (cmax <span class="op">-</span> cmin)</span>
<span id="cb8-22"><a href="#cb8-22"></a>  ret <span class="op">=</span> slope <span class="op">*</span> (x <span class="op">-</span> cmin) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb8-23"><a href="#cb8-23"></a>  <span class="cf">return</span> (ret).astype(dtype)</span>
<span id="cb8-24"><a href="#cb8-24"></a></span>
<span id="cb8-25"><a href="#cb8-25"></a></span>
<span id="cb8-26"><a href="#cb8-26"></a><span class="kw">def</span> toPng(scaled, fname: <span class="bu">str</span>):</span>
<span id="cb8-27"><a href="#cb8-27"></a>  <span class="co">&quot;&quot;&quot;Write a uint8 array `scaled` to a PNG file `fname`&quot;&quot;&quot;</span></span>
<span id="cb8-28"><a href="#cb8-28"></a>  <span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb8-29"><a href="#cb8-29"></a>  newimage <span class="op">=</span> Image.new(<span class="st">&#39;L&#39;</span>, (scaled.shape[<span class="dv">1</span>], scaled.shape[<span class="dv">0</span>]))  <span class="co"># type, (width, height)</span></span>
<span id="cb8-30"><a href="#cb8-30"></a>  newimage.putdata(scaled.ravel())</span>
<span id="cb8-31"><a href="#cb8-31"></a>  newimage.save(fname)</span>
<span id="cb8-32"><a href="#cb8-32"></a></span>
<span id="cb8-33"><a href="#cb8-33"></a></span>
<span id="cb8-34"><a href="#cb8-34"></a><span class="kw">def</span> texToPng(tex, fname, quantiles<span class="op">=</span><span class="va">None</span>, borderFractions<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb8-35"><a href="#cb8-35"></a>  <span class="co">&quot;&quot;&quot;Quantile a texture-shaded array and write it to 8-bit PNG</span></span>
<span id="cb8-36"><a href="#cb8-36"></a></span>
<span id="cb8-37"><a href="#cb8-37"></a><span class="co">  Given `tex`, a 2D array, and a `fname` path to a PNG file, and optionally a</span></span>
<span id="cb8-38"><a href="#cb8-38"></a><span class="co">  2-list `quantiles` (defaults to [0.01, 0.99], i.e., 1% and 99%), clamp the</span></span>
<span id="cb8-39"><a href="#cb8-39"></a><span class="co">  array to the quantile-values and write to a PNG. If `borderFractions`, also a</span></span>
<span id="cb8-40"><a href="#cb8-40"></a><span class="co">  2-list, is given, </span></span>
<span id="cb8-41"><a href="#cb8-41"></a></span>
<span id="cb8-42"><a href="#cb8-42"></a><span class="co">  `[np.round(total * frac) for total, frac in zip(tex.shape, borderFractions)]`</span></span>
<span id="cb8-43"><a href="#cb8-43"></a><span class="co">  </span></span>
<span id="cb8-44"><a href="#cb8-44"></a><span class="co">  pixels on either side of the border in each dimension are ignored in</span></span>
<span id="cb8-45"><a href="#cb8-45"></a><span class="co">  computing the quantiles.</span></span>
<span id="cb8-46"><a href="#cb8-46"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb8-47"><a href="#cb8-47"></a>  <span class="cf">if</span> quantiles <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb8-48"><a href="#cb8-48"></a>    quantiles <span class="op">=</span> [<span class="fl">0.01</span>, <span class="fl">0.99</span>]</span>
<span id="cb8-49"><a href="#cb8-49"></a>  <span class="cf">assert</span> <span class="bu">all</span>([x <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> x <span class="op">&lt;=</span> <span class="dv">1</span> <span class="cf">for</span> x <span class="kw">in</span> quantiles])</span>
<span id="cb8-50"><a href="#cb8-50"></a>  <span class="cf">if</span> borderFractions <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb8-51"><a href="#cb8-51"></a>    minmax <span class="op">=</span> np.quantile(tex.ravel(), quantiles)</span>
<span id="cb8-52"><a href="#cb8-52"></a>  <span class="cf">else</span>:</span>
<span id="cb8-53"><a href="#cb8-53"></a>    <span class="cf">assert</span> <span class="bu">all</span>([x <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> x <span class="op">&lt;</span> <span class="dv">1</span> <span class="cf">for</span> x <span class="kw">in</span> borderFractions])</span>
<span id="cb8-54"><a href="#cb8-54"></a>    border <span class="op">=</span> [<span class="bu">int</span>(np.<span class="bu">round</span>(total <span class="op">*</span> frac)) <span class="cf">for</span> total, frac <span class="kw">in</span> <span class="bu">zip</span>(tex.shape, borderFractions)]</span>
<span id="cb8-55"><a href="#cb8-55"></a>    slices <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">slice</span>(p, <span class="op">-</span>p <span class="cf">if</span> p <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>) <span class="cf">for</span> p <span class="kw">in</span> border)</span>
<span id="cb8-56"><a href="#cb8-56"></a>    minmax <span class="op">=</span> np.quantile(tex[slices].ravel(), quantiles)</span>
<span id="cb8-57"><a href="#cb8-57"></a></span>
<span id="cb8-58"><a href="#cb8-58"></a>  scaled <span class="op">=</span> touint(tex, minmax[<span class="dv">0</span>], minmax[<span class="dv">1</span>], np.uint8)</span>
<span id="cb8-59"><a href="#cb8-59"></a>  toPng(scaled, fname)</span>
<span id="cb8-60"><a href="#cb8-60"></a></span>
<span id="cb8-61"><a href="#cb8-61"></a></span>
<span id="cb8-62"><a href="#cb8-62"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</span>
<span id="cb8-63"><a href="#cb8-63"></a>  arr <span class="op">=</span> np.load(<span class="st">&#39;merged.tif.npy&#39;</span>)</span>
<span id="cb8-64"><a href="#cb8-64"></a>  tex <span class="op">=</span> np.load(<span class="st">&#39;merged.tif.npy.tex.npy&#39;</span>)</span>
<span id="cb8-65"><a href="#cb8-65"></a>  texToPng(tex, <span class="st">&#39;scaled.png&#39;</span>, quantiles<span class="op">=</span>[.<span class="dv">01</span>, <span class="fl">.99</span>], borderFractions<span class="op">=</span>[<span class="fl">1e-2</span>, <span class="fl">1e-2</span>])</span>
<span id="cb8-66"><a href="#cb8-66"></a>  toPng(touint(arr, np.<span class="bu">min</span>(arr), np.<span class="bu">max</span>(arr), np.uint8), <span class="st">&#39;orig.png&#39;</span>)</span></code></pre></div>
<pre><code>for i in orig.png scaled.png; do convert -filter Mitchell -sampling-factor 1x1 -quality 90 -resize 2048 $i $i.small.png; done</code></pre>
<h3 id="original">Original</h3>
<p><img src="orig.png.small.png" alt="original downsampled" /></p>
<h3 id="tex-shaded">Tex-shaded</h3>
<p><img src="scaled.png.small.png" alt="tex-shaded downsampled" /></p>
<h2 id="the-approximation">The approximation</h2>
<p>Is there any way to apply the fractional-Laplacian operator, which is expressed in the frequency-domain as \(|\vec f|^α ⋅ F[x]\) for an input array \(x\), that <em>doesn't</em> require a 2D Fourier transform of \(x\)? Recall that the Fourier transform is a unitary operator—that is, \(F[x]\) can be seen as a matrix–vector product \(\underline F ⋅ \underline x\), where the underlines represent a matrix or vector version of the operator or its input, and \(\underline F\) is a unitary matrix (the complex-domain extension of an orthogonal matrix). This indicates that each element of the output of a Fourier transform is a function of each of the input elements (though because it can do this in \(log(N)\) operations, instead of \(N\), we call it the <em>fast</em> Fourier transform (FFT)). There doesn't seem to be a memory-local way to convert the array of elevations to the Fourier domain, since each frequency bin has contributions from each pixel in the elevation array.</p>
<p>But we do know from linear systems theory that multiplication in the frequency domain is equivalent to convolution in the spatial domain. We can ask if there's any structure to the spatial-domain representation of the fractional-Laplacian \(|\vec f|^α\), i.e., what is \(F^{-1}[|\vec f|^α]\)?</p>
<p>Trawling through the Wikipedia I stumbled on <a href="https://en.wikipedia.org/w/index.php?title=Hankel_transform&amp;oldid=901300195#Relation_to_the_Fourier_transform_(circularly_symmetric_case)">the Hankel transform and its relationship to the Fourier transform of circularly-symmetric functions</a>. Wikipedia notes that for a two-dimensional radial function \(f(r)\), its two-dimensional Fourier transform \(F(\vec k)\) is</p>
<p>$$F(\vec k) = F(k) = 2π\int_0^{\infty} f(r) ⋅ J_0(k r) \cdot r ⋅ dr,$$ where \(J_0(⋅)\) is the Bessel function of the first kind of order 0. In our notation, if we represent the fractional-Laplacian operator as \(l(\vec f) = l(f) = f^α\) ("l" for "Laplacian"), its Fourier transform is, according to <a href="https://www.wolframalpha.com/input/?i=2*pi*Integrate%5Bf%5Ea+*+BesselJ%5B0%2C+k+*+f%5D+*+f%2C+f%2C+0%2C+m%5D">Wolfram Alpha</a>,</p>
<p>$$2π\int_0^m f ⋅ f^α J_0(f r) df = 2π \frac{m^{α + 2}}{α + 2} \cdot {}_{1}F_2([α / 2 + 1], [1, α / 2 + 2], -(r ⋅ m / 2)^2)$$ where</p>
<ul>
<li>\(r\) is my variable for the radius in the spatial domain,</li>
<li>\(1F2\) is a generalized hypergeometric function (not "the" hypergeometric function \(2F1\)!), and</li>
<li>where I left the upper limit of the integral as \(m\) (for "max") because we have a bound on the extent of the frequency domain \(\vec f = [f_x, f_y]'\), since \(-π ≤ f_x &lt; π\) radians per pixel, and same for \(f_y\). (Recall this happens because we are working with a discrete-valued array of elevations \(x\), so the Fourier transform is a discrete-time Fourier transform (DTFT) and is periodic every 2π radians per pixel.)</li>
</ul>
<blockquote>
<p>Odd sidebar. My little knowledge of mathematics is exhausted by wondering why, if I omit the 2π in the expression to Wolfram Alpha, it returns a much more complicated expression including Γ functions. Sympy similar story.</p>
</blockquote>
<p>The constant factors that accrete when working with Fourier transform pairs are usually incredibly tedious to keep track of, especially when evaluating them with the FFT. My normal practice is to get things working up to a constant factor and then see if I need to worry about that factor.</p>
<p>So let us ask what the Fourier transform of an array containing evaluations of the radial function</p>
<p>$$L(r) = {}_{1}F_2([α / 2 + 1], [1, α / 2 + 2], -(r ⋅ π / 2)^2).$$ We use the maximum of the integral in the Hankel transform is \(m=π\). Recall we use "l" and "L" for "Laplacian": \(L(r)\) is the Fourier transform of the fractional-Laplacian \(l(f) = |f|^α\).</p>
<p>We do this in the code snippet below: we evaluate the above generalized hypergeometric function on a 200×200 array of radii. We assume the array's horizontal and vertical axes run from -100 to 99, i.e., assuming one pixel spacing for each element, compute each element's radius \(r\), and evaluate \(L(r)\). Then we look at its 2D FFT, which will be all-real because the input is symmetric. (Recall that in general, the Fourier transform of a real vector will contain complex entries but be conjugate-symmetric about the origin. The Fourier transform will contain zero imaginary components only if its input was symmetric about the origin.)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># export math-hankel.py</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="im">from</span> mpmath <span class="im">import</span> hyper</span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="im">import</span> numpy.fft <span class="im">as</span> fft</span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="im">import</span> pylab <span class="im">as</span> plt</span>
<span id="cb10-6"><a href="#cb10-6"></a>plt.style.use(<span class="st">&#39;ggplot&#39;</span>)</span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="kw">def</span> spatial(r, a):</span>
<span id="cb10-10"><a href="#cb10-10"></a>  <span class="co">&quot;Evaluate L(r), proportional to the Fourier transform of |f|**α&quot;</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>  <span class="cf">return</span> <span class="bu">float</span>(hyper((<span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">1</span>,), (<span class="fl">1.0</span>, <span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">2</span>), <span class="fl">-0.25</span> <span class="op">*</span> (r <span class="op">*</span> np.pi)<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a></span>
<span id="cb10-14"><a href="#cb10-14"></a>xmat, ymat <span class="op">=</span> np.meshgrid(np.arange(<span class="op">-</span><span class="dv">100</span>, <span class="dv">100</span>), np.arange(<span class="op">-</span><span class="dv">100</span>, <span class="dv">100</span>))</span>
<span id="cb10-15"><a href="#cb10-15"></a>rmat <span class="op">=</span> np.sqrt(xmat<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ymat<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb10-16"><a href="#cb10-16"></a>alpha <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>h <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> r: spatial(r, alpha))(rmat)</span></code></pre></div>
<p>Above we use the fabulous <a href="http://mpmath.org/"><code>mpmath</code></a> package—a pure-Python arbitrary-precision package with extensive support for special functions, quadrature integration, linear algebra, etc., started by Fredrik Johansson in 2007 (when he was a teenager)—to compute the generalized hypergeometric function. Next, we'd like to visualize its Fourier transform—hopefully we see something that looks like \(|f|^{0.8}\).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># export math-hankel.py</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="kw">def</span> F2cent(arr):</span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="co">&quot;&quot;&quot;Origin-centered 2D Fourier transform&quot;&quot;&quot;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>  <span class="cf">return</span> fft.fftshift(fft.fft2(fft.ifftshift(arr)))</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="kw">def</span> plotF2cent(arr):</span>
<span id="cb11-8"><a href="#cb11-8"></a>  <span class="co">&quot;&quot;&quot;Given an origin-centered 2D array, plot its 2D Fourier transform&quot;&quot;&quot;</span></span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a>  <span class="kw">def</span> extents(f):</span>
<span id="cb11-11"><a href="#cb11-11"></a>    delta <span class="op">=</span> f[<span class="dv">1</span>] <span class="op">-</span> f[<span class="dv">0</span>]</span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="cf">return</span> [f[<span class="dv">0</span>] <span class="op">-</span> delta <span class="op">/</span> <span class="dv">2</span>, f[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> delta <span class="op">/</span> <span class="dv">2</span>]</span>
<span id="cb11-13"><a href="#cb11-13"></a></span>
<span id="cb11-14"><a href="#cb11-14"></a>  h, w <span class="op">=</span> arr.shape</span>
<span id="cb11-15"><a href="#cb11-15"></a>  x <span class="op">=</span> np.ceil(np.arange(w) <span class="op">-</span> w <span class="op">/</span> <span class="dv">2</span>) <span class="op">/</span> w</span>
<span id="cb11-16"><a href="#cb11-16"></a>  y <span class="op">=</span> np.ceil(np.arange(h) <span class="op">-</span> h <span class="op">/</span> <span class="dv">2</span>) <span class="op">/</span> h</span>
<span id="cb11-17"><a href="#cb11-17"></a>  fig, (sax, fax) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb11-18"><a href="#cb11-18"></a></span>
<span id="cb11-19"><a href="#cb11-19"></a>  sax.imshow(</span>
<span id="cb11-20"><a href="#cb11-20"></a>      arr,</span>
<span id="cb11-21"><a href="#cb11-21"></a>      aspect<span class="op">=</span><span class="st">&#39;equal&#39;</span>,</span>
<span id="cb11-22"><a href="#cb11-22"></a>      interpolation<span class="op">=</span><span class="st">&#39;none&#39;</span>,</span>
<span id="cb11-23"><a href="#cb11-23"></a>      extent<span class="op">=</span>extents(x <span class="op">*</span> w) <span class="op">+</span> extents(y <span class="op">*</span> h),</span>
<span id="cb11-24"><a href="#cb11-24"></a>      origin<span class="op">=</span><span class="st">&#39;lower&#39;</span>)</span>
<span id="cb11-25"><a href="#cb11-25"></a></span>
<span id="cb11-26"><a href="#cb11-26"></a>  fax.imshow(</span>
<span id="cb11-27"><a href="#cb11-27"></a>      np.real(F2cent(arr)),</span>
<span id="cb11-28"><a href="#cb11-28"></a>      aspect<span class="op">=</span><span class="st">&#39;equal&#39;</span>,</span>
<span id="cb11-29"><a href="#cb11-29"></a>      interpolation<span class="op">=</span><span class="st">&#39;none&#39;</span>,</span>
<span id="cb11-30"><a href="#cb11-30"></a>      extent<span class="op">=</span>extents(x) <span class="op">+</span> extents(y),</span>
<span id="cb11-31"><a href="#cb11-31"></a>      origin<span class="op">=</span><span class="st">&#39;lower&#39;</span>)</span>
<span id="cb11-32"><a href="#cb11-32"></a>  sax.grid(<span class="va">False</span>)</span>
<span id="cb11-33"><a href="#cb11-33"></a>  fax.grid(<span class="va">False</span>)</span>
<span id="cb11-34"><a href="#cb11-34"></a>  sax.set_xlabel(<span class="st">&#39;pixel&#39;</span>)</span>
<span id="cb11-35"><a href="#cb11-35"></a>  fax.set_xlabel(<span class="st">&#39;cycles/pixel&#39;</span>)</span>
<span id="cb11-36"><a href="#cb11-36"></a></span>
<span id="cb11-37"><a href="#cb11-37"></a>  <span class="cf">return</span> fig, sax, fax</span>
<span id="cb11-38"><a href="#cb11-38"></a></span>
<span id="cb11-39"><a href="#cb11-39"></a></span>
<span id="cb11-40"><a href="#cb11-40"></a>hplots <span class="op">=</span> plotF2cent(h)</span>
<span id="cb11-41"><a href="#cb11-41"></a>hplots[<span class="dv">1</span>].set_title(<span class="st">&#39;L(r): spatial-domain&#39;</span>)</span>
<span id="cb11-42"><a href="#cb11-42"></a>hplots[<span class="dv">2</span>].set_title(<span class="st">&#39;F[L(r)]: frequency-domain&#39;</span>)</span>
<span id="cb11-43"><a href="#cb11-43"></a>plt.savefig(<span class="st">&#39;full-hankel.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb11-44"><a href="#cb11-44"></a>plt.savefig(<span class="st">&#39;full-hankel.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb11-45"><a href="#cb11-45"></a></span>
<span id="cb11-46"><a href="#cb11-46"></a>actual <span class="op">=</span> np.real(F2cent(h))[<span class="dv">100</span>, :]</span>
<span id="cb11-47"><a href="#cb11-47"></a>f <span class="op">=</span> np.ceil(np.arange(<span class="dv">200</span>) <span class="op">-</span> <span class="dv">200</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">/</span> <span class="dv">200</span></span>
<span id="cb11-48"><a href="#cb11-48"></a>expected <span class="op">=</span> np.<span class="bu">abs</span>(f <span class="op">*</span> <span class="dv">4</span>)<span class="op">**</span>alpha</span>
<span id="cb11-49"><a href="#cb11-49"></a>plt.figure()</span>
<span id="cb11-50"><a href="#cb11-50"></a>plt.plot(f, actual, <span class="st">&#39;-&#39;</span>, f, expected, <span class="st">&#39;--&#39;</span>, f, actual <span class="op">/</span> expected, <span class="st">&#39;.&#39;</span>)</span>
<span id="cb11-51"><a href="#cb11-51"></a>plt.xlabel(<span class="st">&#39;f (cycles/pixel)&#39;</span>)</span>
<span id="cb11-52"><a href="#cb11-52"></a>plt.legend([<span class="st">&#39;actual&#39;</span>, <span class="st">&#39;expected&#39;</span>, <span class="st">&#39;actual/expected&#39;</span>])</span>
<span id="cb11-53"><a href="#cb11-53"></a>plt.title(<span class="st">&#39;Cut of actual F[L(r)] versus expected |4⋅f|^0.8&#39;</span>)</span>
<span id="cb11-54"><a href="#cb11-54"></a>plt.savefig(<span class="st">&#39;full-hankel-actual-expected.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb11-55"><a href="#cb11-55"></a>plt.savefig(<span class="st">&#39;full-hankel-actual-expected.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span></code></pre></div>
<p><img src="full-hankel.png" alt="An array of evaluating the expression we computed for the Fourier transform of the fractional-Laplacian operator, and it&#39;s actual Fourier transform" /></p>
<p>Above: an array of evaluating the expression we computed for the Fourier transform of the fractional-Laplacian operator, and it's actual Fourier transform.</p>
<p><img src="full-hankel-actual-expected.svg" alt="Comparing the actual frequency response of our expression for the spatial-domain equivalent of the fractional-Laplacial, versus the expected frequency response, and their difference, which is approximately 1.024" /></p>
<p>Above: Comparing the actual frequency response of our expression for the spatial-domain equivalent of the fractional-Laplacial, versus the expected frequency response, and their difference, which is approximately 1.024.</p>
<p>This is a success! First, note that the 200×200 array on the left is close to zero: it has a bright center, and decays quickly as the radius from the center–origin grows. Next, note that its 2D Fourier transform is indeed what we had hoped: it sweeps out \(∝|f|^{α=0.8}\) radially, for angular radii between 0 and π radians (normalized here to cycles instead of radians: the axes between ±0.5 cycles per pixel correspond to ±π radians per pixel). (The symbol "\(∝\)" is read as "proportional to".)</p>
<p>The second plot above shows the near-constant ratio between the center-cut through the FFT of the spatial filter \(L(r)\) and a scaled version of what we expect. Comparing \(|4f|^α\), for \(α=0.8\), to the cut through the FFT's output, we see a very-nearly-constant ratio of 1.024. Do note that the actual value inside the absolute value is irrelevant, and amounts only to scaling the texture-shaded output.</p>
<p><strong>However</strong>, we cannot use \(L(r)\) as a spatial-domain equivalent of texture-shading because recall that the original algorithm requires</p>
<p>$$y = F^{-1}[F[x] ⋅ |\vec f|^α],$$ but \(|\vec f|^α\) includes the <em>corners</em> of the frequency domain, not the radial pattern we see from the circular bull's-eye chart above, where the corners in the frequency domain get zero weight. We might use \(L(r)\) nonetheless and accept the infidelity to the texture-shading algorithm, but we don't need to. If we decimate the spatial-domain filter \(L(r)\) by two, then we effectively get the middle-half of its frequency response, which will be \(∝|f|^α\) all the way out to its edges. The Scipy ecosystem provides several ways to <a href="https://docs.scipy.org/doc/scipy/reference/signal.html#filter-design">design halfband filters</a>. A simple example to demonstrate the idea will suffice: design an 8th order low-pass Butterworth filter and apply it along rows and columns of the spatial-domain filter, then downsample the result (throw away every other row/column):</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># export math-hankel.py</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="im">import</span> scipy.signal <span class="im">as</span> sig</span>
<span id="cb12-3"><a href="#cb12-3"></a>lpf <span class="op">=</span> sig.iirfilter(<span class="dv">8</span>, <span class="fl">0.5</span>, btype<span class="op">=</span><span class="st">&#39;lowpass&#39;</span>, ftype<span class="op">=</span><span class="st">&#39;butter&#39;</span>)</span>
<span id="cb12-4"><a href="#cb12-4"></a>hiir <span class="op">=</span> sig.filtfilt(<span class="op">*</span>lpf, sig.filtfilt(<span class="op">*</span>lpf, h, axis<span class="op">=</span><span class="dv">0</span>), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a>lpfplots <span class="op">=</span> plotF2cent(hiir)</span>
<span id="cb12-7"><a href="#cb12-7"></a>decplots <span class="op">=</span> plotF2cent(hiir[:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>, :<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>])</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a>lpfplots[<span class="dv">1</span>].set_title(<span class="st">&#39;LPF[L(r)]&#39;</span>)</span>
<span id="cb12-10"><a href="#cb12-10"></a>lpfplots[<span class="dv">2</span>].set_title(<span class="st">&#39;F[LPF[L(r)]]&#39;</span>)</span>
<span id="cb12-11"><a href="#cb12-11"></a>lpfplots[<span class="dv">0</span>].savefig(<span class="st">&#39;lpf-hankel.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb12-12"><a href="#cb12-12"></a>lpfplots[<span class="dv">0</span>].savefig(<span class="st">&#39;lpf-hankel.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb12-13"><a href="#cb12-13"></a></span>
<span id="cb12-14"><a href="#cb12-14"></a>decplots[<span class="dv">1</span>].set_title(<span class="st">&#39;HB[L(r)]&#39;</span>)</span>
<span id="cb12-15"><a href="#cb12-15"></a>decplots[<span class="dv">2</span>].set_title(<span class="st">&#39;F[HB[L(r)]]&#39;</span>)</span>
<span id="cb12-16"><a href="#cb12-16"></a>decplots[<span class="dv">0</span>].savefig(<span class="st">&#39;hb-hankel.png&#39;</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span>
<span id="cb12-17"><a href="#cb12-17"></a>decplots[<span class="dv">0</span>].savefig(<span class="st">&#39;hb-hankel.svg&#39;</span>, bbox_inches<span class="op">=</span><span class="st">&#39;tight&#39;</span>)</span></code></pre></div>
<p>The results are positive: while this filtering process can certainly be improved, we have obtained a spatial-domain filter that closely-approximates the fractional-Laplacian frequency-domain operator needed by the texture-shading algorithm.</p>
<p><img src="lpf-hankel.png" alt="Low-pass-filtered version of our initial spatial-domain-created filter" /></p>
<p>Above: low-pass-filtered version of our initial spatial-domain-created filter.</p>
<p><img src="hb-hankel.png" alt="Halfbanded (decimated) version of our initial spatial-dmain-created filter: this meets the requirements of the original texture-shading algorithm" /></p>
<p>Above: halfbanded (decimated) version of our initial spatial-dmain-created filter: this meets the requirements of the original texture-shading algorithm.</p>
<h2 id="a-more-complete-implementation-of-the-approximation">A more complete implementation of the approximation</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># export texshade/hankel.py</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="im">from</span> mpmath <span class="im">import</span> hyper</span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="im">from</span> scipy <span class="im">import</span> signal</span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="im">from</span> scipy.signal <span class="im">import</span> convolve2d</span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="im">import</span> numpy.fft <span class="im">as</span> fft</span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="im">import</span> functools</span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> interp1d</span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="at">@functools.lru_cache</span>(maxsize<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb13-12"><a href="#cb13-12"></a><span class="kw">def</span> spatial(r, a, integralMax<span class="op">=</span>np.pi):</span>
<span id="cb13-13"><a href="#cb13-13"></a>  <span class="co">&quot;Evaluate L(r), proportional to the Fourier transform of |f|**α&quot;</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>  <span class="co"># Wolfram Alpha: `2*pi*Integrate[f^a * BesselJ[0, k * f] * f, f, 0, m]`</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>  <span class="cf">return</span> <span class="bu">float</span>(hyper((<span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">1</span>,), (<span class="fl">1.0</span>, <span class="fl">0.5</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">2</span>), <span class="fl">-0.25</span> <span class="op">*</span> (r <span class="op">*</span> integralMax)<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb13-16"><a href="#cb13-16"></a></span>
<span id="cb13-17"><a href="#cb13-17"></a></span>
<span id="cb13-18"><a href="#cb13-18"></a><span class="kw">def</span> vec(v):</span>
<span id="cb13-19"><a href="#cb13-19"></a>  <span class="co">&quot;Convert a Numpy array to a column vector&quot;</span></span>
<span id="cb13-20"><a href="#cb13-20"></a>  <span class="cf">return</span> v.reshape(v.size, <span class="dv">-1</span>)</span>
<span id="cb13-21"><a href="#cb13-21"></a></span>
<span id="cb13-22"><a href="#cb13-22"></a></span>
<span id="cb13-23"><a href="#cb13-23"></a><span class="kw">def</span> fullHankel(n: <span class="bu">int</span>, alpha: <span class="bu">float</span>, interpMethod<span class="op">=</span><span class="va">True</span>, sampleSpacing<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb13-24"><a href="#cb13-24"></a>  <span class="co">&quot;&quot;&quot;Build a FIR filter approximating the fractional-Laplacian operator in the</span></span>
<span id="cb13-25"><a href="#cb13-25"></a><span class="co">  middle of its frequency response (non-ideal)</span></span>
<span id="cb13-26"><a href="#cb13-26"></a></span>
<span id="cb13-27"><a href="#cb13-27"></a><span class="co">  The returned array will be an `2 * n` by `2 * n` array. `alpha` is the scale</span></span>
<span id="cb13-28"><a href="#cb13-28"></a><span class="co">  fraction parameter that governs the amount of sharpening done by the</span></span>
<span id="cb13-29"><a href="#cb13-29"></a><span class="co">  fractional-Laplacian operator.</span></span>
<span id="cb13-30"><a href="#cb13-30"></a></span>
<span id="cb13-31"><a href="#cb13-31"></a><span class="co">  If `interpMethod=True`, then the values in the filter are</span></span>
<span id="cb13-32"><a href="#cb13-32"></a><span class="co">  linearly-interpolated from a grid of samples of the true function (via Hankel</span></span>
<span id="cb13-33"><a href="#cb13-33"></a><span class="co">  transform, implemented in `hankel.spatial`), sampled every `sampleSpacing`</span></span>
<span id="cb13-34"><a href="#cb13-34"></a><span class="co">  pixels. By default this is the case, and `sampleSpacing` is set to 1e-2</span></span>
<span id="cb13-35"><a href="#cb13-35"></a><span class="co">  pixels. This grid is saved to disk.</span></span>
<span id="cb13-36"><a href="#cb13-36"></a></span>
<span id="cb13-37"><a href="#cb13-37"></a><span class="co">  If `interpMethod=False`, then each pixel in the output array is exactly</span></span>
<span id="cb13-38"><a href="#cb13-38"></a><span class="co">  calculated via `hankel.spatial`. This might be much slower.</span></span>
<span id="cb13-39"><a href="#cb13-39"></a></span>
<span id="cb13-40"><a href="#cb13-40"></a><span class="co">  The returned array has a Fourier transform of $|f|^α$ where $|f| &lt; π$ radians</span></span>
<span id="cb13-41"><a href="#cb13-41"></a><span class="co">  per sample, and zero otherwise: that is, a circle inscribed in the unit square</span></span>
<span id="cb13-42"><a href="#cb13-42"></a><span class="co">  that contains the fractal response surrounded by zeros to the corners. This</span></span>
<span id="cb13-43"><a href="#cb13-43"></a><span class="co">  isn&#39;t exactly the same as the fractional-Laplacian operator, which is $|f|^α$</span></span>
<span id="cb13-44"><a href="#cb13-44"></a><span class="co">  for all $|f|$, even out to the corners.</span></span>
<span id="cb13-45"><a href="#cb13-45"></a></span>
<span id="cb13-46"><a href="#cb13-46"></a><span class="co">  See `hankel.halfHankel` for the fully-approximating version of this.</span></span>
<span id="cb13-47"><a href="#cb13-47"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb13-48"><a href="#cb13-48"></a>  rvec <span class="op">=</span> np.arange(<span class="op">-</span>n, n)</span>
<span id="cb13-49"><a href="#cb13-49"></a>  rmat <span class="op">=</span> np.sqrt(vec(rvec)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> vec(rvec).T<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb13-50"><a href="#cb13-50"></a></span>
<span id="cb13-51"><a href="#cb13-51"></a>  <span class="cf">if</span> interpMethod:</span>
<span id="cb13-52"><a href="#cb13-52"></a>    <span class="cf">if</span> <span class="kw">not</span> sampleSpacing:</span>
<span id="cb13-53"><a href="#cb13-53"></a>      sampleSpacing <span class="op">=</span> <span class="fl">1e-2</span></span>
<span id="cb13-54"><a href="#cb13-54"></a>    data <span class="op">=</span> precomputeLoad(alpha, np.ceil(np.sqrt(<span class="dv">2</span>) <span class="op">*</span> n <span class="op">*</span> <span class="fl">1.01</span>), sampleSpacing)</span>
<span id="cb13-55"><a href="#cb13-55"></a>    oned <span class="op">=</span> interp1d(data[<span class="st">&#39;r&#39;</span>], data[<span class="st">&#39;h&#39;</span>])</span>
<span id="cb13-56"><a href="#cb13-56"></a>    hmat <span class="op">=</span> oned(rmat)</span>
<span id="cb13-57"><a href="#cb13-57"></a>  <span class="cf">else</span>:</span>
<span id="cb13-58"><a href="#cb13-58"></a>    fun <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x: spatial(x, alpha))</span>
<span id="cb13-59"><a href="#cb13-59"></a>    hmat <span class="op">=</span> fun(rmat)</span>
<span id="cb13-60"><a href="#cb13-60"></a>  <span class="cf">return</span> hmat</span>
<span id="cb13-61"><a href="#cb13-61"></a></span>
<span id="cb13-62"><a href="#cb13-62"></a></span>
<span id="cb13-63"><a href="#cb13-63"></a><span class="kw">def</span> designHalfband(N: <span class="bu">int</span>, transitionWidth: <span class="bu">float</span>):</span>
<span id="cb13-64"><a href="#cb13-64"></a>  <span class="co">&quot;&quot;&quot;Use the Remez exchange to design a halfband low-pass filter</span></span>
<span id="cb13-65"><a href="#cb13-65"></a></span>
<span id="cb13-66"><a href="#cb13-66"></a><span class="co">  `N` taps, with `transitionWidth &lt; 0.5` governing the transition band.</span></span>
<span id="cb13-67"><a href="#cb13-67"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb13-68"><a href="#cb13-68"></a>  <span class="cf">if</span> N <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb13-69"><a href="#cb13-69"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;N must be even&#39;</span>)</span>
<span id="cb13-70"><a href="#cb13-70"></a>  <span class="cf">if</span> N <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb13-71"><a href="#cb13-71"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;N must be &gt; 1&#39;</span>)</span>
<span id="cb13-72"><a href="#cb13-72"></a>  <span class="cf">if</span> <span class="kw">not</span> (transitionWidth <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> transitionWidth <span class="op">&lt;</span> <span class="fl">0.5</span>):</span>
<span id="cb13-73"><a href="#cb13-73"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;Need 0 &lt; transitionWidth &lt; 0.5&#39;</span>)</span>
<span id="cb13-74"><a href="#cb13-74"></a>  bands <span class="op">=</span> np.array([<span class="fl">0.</span>, <span class="fl">.25</span> <span class="op">-</span> transitionWidth, <span class="fl">.25</span> <span class="op">+</span> transitionWidth, <span class="fl">.5</span>])</span>
<span id="cb13-75"><a href="#cb13-75"></a>  h <span class="op">=</span> signal.remez(N <span class="op">+</span> <span class="dv">1</span>, bands, [<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">1</span>])</span>
<span id="cb13-76"><a href="#cb13-76"></a>  h[<span class="bu">abs</span>(h) <span class="op">&lt;=</span> <span class="fl">1e-4</span>] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb13-77"><a href="#cb13-77"></a>  <span class="cf">return</span> h</span>
<span id="cb13-78"><a href="#cb13-78"></a></span>
<span id="cb13-79"><a href="#cb13-79"></a></span>
<span id="cb13-80"><a href="#cb13-80"></a><span class="kw">def</span> halfband(hmat, taps<span class="op">=</span><span class="dv">128</span>, transitionWidth<span class="op">=</span><span class="fl">0.03</span>):</span>
<span id="cb13-81"><a href="#cb13-81"></a>  <span class="co">&quot;&quot;&quot;Decimate an array by half</span></span>
<span id="cb13-82"><a href="#cb13-82"></a></span>
<span id="cb13-83"><a href="#cb13-83"></a><span class="co">  Design a low-pass halfband filter with `taps` length and with transition band</span></span>
<span id="cb13-84"><a href="#cb13-84"></a><span class="co">  `transitionWidth` and apply it to the input array `hmat`, then throw away</span></span>
<span id="cb13-85"><a href="#cb13-85"></a><span class="co">  every other sample (2x downsample).</span></span>
<span id="cb13-86"><a href="#cb13-86"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb13-87"><a href="#cb13-87"></a>  hbFilter <span class="op">=</span> designHalfband(taps, transitionWidth)</span>
<span id="cb13-88"><a href="#cb13-88"></a>  doubleFilter <span class="op">=</span> convolve2d(</span>
<span id="cb13-89"><a href="#cb13-89"></a>      convolve2d(hmat, vec(hbFilter), mode<span class="op">=</span><span class="st">&#39;same&#39;</span>), vec(hbFilter).T, mode<span class="op">=</span><span class="st">&#39;same&#39;</span>)</span>
<span id="cb13-90"><a href="#cb13-90"></a>  n <span class="op">=</span> hmat.shape[<span class="dv">0</span>]</span>
<span id="cb13-91"><a href="#cb13-91"></a>  finalFilter <span class="op">=</span> doubleFilter[:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>, :<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>] <span class="cf">if</span> n <span class="op">%</span> <span class="dv">4</span> <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> doubleFilter[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>:<span class="dv">2</span>]</span>
<span id="cb13-92"><a href="#cb13-92"></a>  <span class="cf">return</span> finalFilter</span>
<span id="cb13-93"><a href="#cb13-93"></a></span>
<span id="cb13-94"><a href="#cb13-94"></a></span>
<span id="cb13-95"><a href="#cb13-95"></a><span class="kw">def</span> halfHankel(n, alpha, interpMethod<span class="op">=</span><span class="va">True</span>, sampleSpacing<span class="op">=</span><span class="va">None</span>, hbTaps<span class="op">=</span><span class="dv">128</span>, hbtransitionWidth<span class="op">=</span><span class="fl">0.03</span>):</span>
<span id="cb13-96"><a href="#cb13-96"></a>  <span class="co">&quot;&quot;&quot;Build the FIR filter approximating the fractional-Laplacian operator over</span></span>
<span id="cb13-97"><a href="#cb13-97"></a><span class="co">  all frequencies (ideal)</span></span>
<span id="cb13-98"><a href="#cb13-98"></a></span>
<span id="cb13-99"><a href="#cb13-99"></a><span class="co">  Returns an `n` by `n` array representing the spatial-domain FIR filter that</span></span>
<span id="cb13-100"><a href="#cb13-100"></a><span class="co">  approximates the `alpha`-detail fractional-Laplacian operator in its total</span></span>
<span id="cb13-101"><a href="#cb13-101"></a><span class="co">  frequency response. This should be used instead of `hankel.fullHankel`.</span></span>
<span id="cb13-102"><a href="#cb13-102"></a></span>
<span id="cb13-103"><a href="#cb13-103"></a><span class="co">  `interpMethod` and `sampleSpacing` keyword arguments per `hankel.fullHankel`,</span></span>
<span id="cb13-104"><a href="#cb13-104"></a><span class="co">  which generates the non-ideal spatial filter.</span></span>
<span id="cb13-105"><a href="#cb13-105"></a></span>
<span id="cb13-106"><a href="#cb13-106"></a><span class="co">  A half-band filter of `hbTaps` length and with transition band</span></span>
<span id="cb13-107"><a href="#cb13-107"></a><span class="co">  `hbtransitionWidth` is designed (via `hankel.designHalfband`) and used to</span></span>
<span id="cb13-108"><a href="#cb13-108"></a><span class="co">  decimate the output of `hankel.fullHankel`. This decimated array is returned.</span></span>
<span id="cb13-109"><a href="#cb13-109"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb13-110"><a href="#cb13-110"></a>  <span class="cf">return</span> halfband(</span>
<span id="cb13-111"><a href="#cb13-111"></a>      fullHankel(n, alpha, interpMethod<span class="op">=</span>interpMethod, sampleSpacing<span class="op">=</span>sampleSpacing),</span>
<span id="cb13-112"><a href="#cb13-112"></a>      taps<span class="op">=</span>hbTaps,</span>
<span id="cb13-113"><a href="#cb13-113"></a>      transitionWidth<span class="op">=</span>hbtransitionWidth)</span>
<span id="cb13-114"><a href="#cb13-114"></a></span>
<span id="cb13-115"><a href="#cb13-115"></a></span>
<span id="cb13-116"><a href="#cb13-116"></a><span class="kw">def</span> precomputeLoad(alpha: <span class="bu">float</span>, N: <span class="bu">int</span>, spacing: <span class="bu">float</span>):</span>
<span id="cb13-117"><a href="#cb13-117"></a>  <span class="co">&quot;&quot;&quot;Store and load gridded evaluations of the spatial-domain function</span></span>
<span id="cb13-118"><a href="#cb13-118"></a><span class="co">  `hankel.spatial` to disk</span></span>
<span id="cb13-119"><a href="#cb13-119"></a></span>
<span id="cb13-120"><a href="#cb13-120"></a><span class="co">  Given `alpha` the detail parameter of the fractional-Laplacian operator, and</span></span>
<span id="cb13-121"><a href="#cb13-121"></a><span class="co">  `N` and `spacing`, imagine generating `x = np.arange(0, N, spacing)`. This</span></span>
<span id="cb13-122"><a href="#cb13-122"></a><span class="co">  function will return `hankel.spatial` evaluated for each sample of that `x`.</span></span>
<span id="cb13-123"><a href="#cb13-123"></a></span>
<span id="cb13-124"><a href="#cb13-124"></a><span class="co">  The data is cached to the current directory, e.g., `hankel-alpha-0.8.npz` for</span></span>
<span id="cb13-125"><a href="#cb13-125"></a><span class="co">  `alpha=0.8`. This function will use as much of the pre-computed data from this</span></span>
<span id="cb13-126"><a href="#cb13-126"></a><span class="co">  NPZ file as possible, compute whatever is missing from this file, and update</span></span>
<span id="cb13-127"><a href="#cb13-127"></a><span class="co">  the file.</span></span>
<span id="cb13-128"><a href="#cb13-128"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb13-129"><a href="#cb13-129"></a>  <span class="im">import</span> os.path</span>
<span id="cb13-130"><a href="#cb13-130"></a>  fun <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x: spatial(x, alpha))</span>
<span id="cb13-131"><a href="#cb13-131"></a>  r <span class="op">=</span> np.arange(<span class="dv">0</span>, N, spacing)</span>
<span id="cb13-132"><a href="#cb13-132"></a>  fname <span class="op">=</span> <span class="st">&#39;hankel-alpha-</span><span class="sc">{}</span><span class="st">&#39;</span>.<span class="bu">format</span>(alpha)</span>
<span id="cb13-133"><a href="#cb13-133"></a>  <span class="cf">if</span> os.path.isfile(fname <span class="op">+</span> <span class="st">&#39;.npz&#39;</span>):</span>
<span id="cb13-134"><a href="#cb13-134"></a>    npz <span class="op">=</span> np.load(fname <span class="op">+</span> <span class="st">&#39;.npz&#39;</span>)</span>
<span id="cb13-135"><a href="#cb13-135"></a>    rsave <span class="op">=</span> npz[<span class="st">&#39;x&#39;</span>]</span>
<span id="cb13-136"><a href="#cb13-136"></a>    hsave <span class="op">=</span> npz[<span class="st">&#39;y&#39;</span>]</span>
<span id="cb13-137"><a href="#cb13-137"></a></span>
<span id="cb13-138"><a href="#cb13-138"></a>    rnew <span class="op">=</span> np.sort(np.setdiff1d(r, rsave))</span>
<span id="cb13-139"><a href="#cb13-139"></a>    hnew <span class="op">=</span> fun(rnew) <span class="cf">if</span> rnew.size <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> []</span>
<span id="cb13-140"><a href="#cb13-140"></a></span>
<span id="cb13-141"><a href="#cb13-141"></a>    r <span class="op">=</span> np.hstack([rsave, rnew])</span>
<span id="cb13-142"><a href="#cb13-142"></a>    h <span class="op">=</span> np.hstack([hsave, hnew])</span>
<span id="cb13-143"><a href="#cb13-143"></a>    idx <span class="op">=</span> np.argsort(r)  <span class="co"># wasteful but resorting 1k vec is fast</span></span>
<span id="cb13-144"><a href="#cb13-144"></a>    r <span class="op">=</span> r[idx]</span>
<span id="cb13-145"><a href="#cb13-145"></a>    h <span class="op">=</span> h[idx]</span>
<span id="cb13-146"><a href="#cb13-146"></a>  <span class="cf">else</span>:</span>
<span id="cb13-147"><a href="#cb13-147"></a>    h <span class="op">=</span> fun(r)</span>
<span id="cb13-148"><a href="#cb13-148"></a>  np.savez(fname, x<span class="op">=</span>r, y<span class="op">=</span>h)</span>
<span id="cb13-149"><a href="#cb13-149"></a>  <span class="cf">return</span> <span class="bu">dict</span>(r<span class="op">=</span>r, h<span class="op">=</span>h)</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="co"># export hankel-demo.py</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="im">import</span> texshade</span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="im">import</span> postprocess</span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="im">from</span> scipy.signal <span class="im">import</span> fftconvolve</span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif.npy&#39;</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>arr <span class="op">=</span> np.load(fname)</span>
<span id="cb14-9"><a href="#cb14-9"></a></span>
<span id="cb14-10"><a href="#cb14-10"></a>clip <span class="op">=</span> <span class="va">True</span></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="cf">if</span> clip:</span>
<span id="cb14-12"><a href="#cb14-12"></a>  arr <span class="op">=</span> arr[<span class="op">-</span><span class="dv">1500</span>:, <span class="dv">-1500</span>:]</span>
<span id="cb14-13"><a href="#cb14-13"></a></span>
<span id="cb14-14"><a href="#cb14-14"></a>alpha <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb14-15"><a href="#cb14-15"></a></span>
<span id="cb14-16"><a href="#cb14-16"></a>postprocess.texToPng(</span>
<span id="cb14-17"><a href="#cb14-17"></a>    texshade.texshadeFFT(arr, alpha),</span>
<span id="cb14-18"><a href="#cb14-18"></a>    <span class="st">&#39;orig-texshade-alpha-</span><span class="sc">{}{}</span><span class="st">.png&#39;</span>.<span class="bu">format</span>(alpha, <span class="st">&#39;-clip&#39;</span> <span class="cf">if</span> clip <span class="cf">else</span> <span class="st">&#39;&#39;</span>),</span>
<span id="cb14-19"><a href="#cb14-19"></a>    quantiles<span class="op">=</span>[.<span class="dv">01</span>, <span class="fl">.99</span>],</span>
<span id="cb14-20"><a href="#cb14-20"></a>    borderFractions<span class="op">=</span>[<span class="fl">1e-2</span>, <span class="fl">1e-2</span>])</span>
<span id="cb14-21"><a href="#cb14-21"></a></span>
<span id="cb14-22"><a href="#cb14-22"></a>Nwidth <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb14-23"><a href="#cb14-23"></a>Nhalfband <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb14-24"><a href="#cb14-24"></a></span>
<span id="cb14-25"><a href="#cb14-25"></a>h <span class="op">=</span> texshade.hankel.halfHankel(Nwidth, alpha, hbTaps<span class="op">=</span>Nhalfband)</span>
<span id="cb14-26"><a href="#cb14-26"></a><span class="bu">print</span>(<span class="st">&#39;halfbanded&#39;</span>, h.shape)</span>
<span id="cb14-27"><a href="#cb14-27"></a>postprocess.texToPng(</span>
<span id="cb14-28"><a href="#cb14-28"></a>    fftconvolve(arr, h, mode<span class="op">=</span><span class="st">&#39;same&#39;</span>),</span>
<span id="cb14-29"><a href="#cb14-29"></a>    <span class="st">&#39;hankel-texshade-alpha-</span><span class="sc">{}</span><span class="st">-n-</span><span class="sc">{}{}</span><span class="st">.png&#39;</span>.<span class="bu">format</span>(alpha, Nwidth, <span class="st">&#39;-clip&#39;</span> <span class="cf">if</span> clip <span class="cf">else</span> <span class="st">&#39;&#39;</span>),</span>
<span id="cb14-30"><a href="#cb14-30"></a>    quantiles<span class="op">=</span>[.<span class="dv">01</span>, <span class="fl">.99</span>],</span>
<span id="cb14-31"><a href="#cb14-31"></a>    borderFractions<span class="op">=</span>[<span class="fl">1e-2</span>, <span class="fl">1e-2</span>])</span>
<span id="cb14-32"><a href="#cb14-32"></a></span>
<span id="cb14-33"><a href="#cb14-33"></a>hFull <span class="op">=</span> texshade.hankel.fullHankel(Nwidth, alpha)</span>
<span id="cb14-34"><a href="#cb14-34"></a><span class="bu">print</span>(<span class="st">&#39;non-halfbanded&#39;</span>, hFull.shape)</span>
<span id="cb14-35"><a href="#cb14-35"></a>postprocess.texToPng(</span>
<span id="cb14-36"><a href="#cb14-36"></a>    fftconvolve(arr, hFull, mode<span class="op">=</span><span class="st">&#39;same&#39;</span>),</span>
<span id="cb14-37"><a href="#cb14-37"></a>    <span class="st">&#39;hankel-texshadeFullband-alpha-</span><span class="sc">{}</span><span class="st">-n-</span><span class="sc">{}{}</span><span class="st">.png&#39;</span>.<span class="bu">format</span>(alpha, Nwidth, <span class="st">&#39;-clip&#39;</span> <span class="cf">if</span> clip <span class="cf">else</span> <span class="st">&#39;&#39;</span>),</span>
<span id="cb14-38"><a href="#cb14-38"></a>    quantiles<span class="op">=</span>[.<span class="dv">01</span>, <span class="fl">.99</span>],</span>
<span id="cb14-39"><a href="#cb14-39"></a>    borderFractions<span class="op">=</span>[<span class="fl">1e-2</span>, <span class="fl">1e-2</span>])</span></code></pre></div>
<p>We can compare the output of the original texture-shading algorithm:</p>
<p><img src="orig-texshade-alpha-0.8-clip.png" alt="Texshaded clip" /></p>
<p>with that of the Hankel approximation:</p>
<p><img src="hankel-texshade-alpha-0.8-n-500-clip.png" alt="Hankel-approximated texshaded clip" /></p>
<p>Both are very close. Toggling between them only reveals slight contrast differences due to the different levels obtained for the quantiles—these differences are likely caused by the artifacts at the edges.</p>
<p>In the above demo code, we ask Scipy's <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.fftconvolve.html"><code>fftconvolve</code></a> to apply the spatial-domain filtering, which behind the scenes uses a full-sized FFT just like the original method. However, we can make this much more memory-efficient, while retaining its speed, by using the overlap-add (or overlap-save) technique of fast-convolution.</p>
<h2 id="overlap-save-method-for-fast-convolution">Overlap-save method for fast-convolution</h2>
<p>The textbook definition of convolving two signals in the spatial domain is a quadratic \(O(N^2)\) operation. Since convolution in the spatial domain is mathematically equivalent to multiplication in the frequency domain, and the FFT is a log-linear \(O(N \log N)\) operation, this is usually much faster—this is why we use <code>fftconvolve</code> above. The drawback of the FFT-based alternative to direct convolution is that it requires we run the FFT on the signals of interest—with a potentially prohibitive memory burden.</p>
<p>The overlap-save method (and its closely-related sibling, the overlap-add method) allow us to convolve signals more intelligently: it still uses FFTs, so the overall theoretical runtime complexity remains log-linear, but it uses <em>many small</em> FFTs so memory consumption remains reasonable. I prefer overlap-save because it partitions the <em>output</em> array into non-overlapping segments that each step of the algorithm fills in (and which may be parallelized). Each step of the overlap-save algorithm reaches for segments of <em>input</em> that may overlap with other steps, but this overlap is read-only.</p>
<blockquote>
<p>In contrast, overlap-add splits the <em>input</em> array into non-overlapping segments. Each step of that algorithm has to potentially modify previously-computed samples of the <em>output</em>, which makes parallelization much more nasty (requiring locks or careful orchestration of the sequence of steps).</p>
</blockquote>
<p>The overlap-save implementation I wrote is largely out of the scope of this texture-shading library, so let's just import it and show how we can use it, along with memory-mapped inputs and outputs to <em>really</em> save memory.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="co"># export texshade/texshade.py</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="im">from</span> ols <span class="im">import</span> ols</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="im">from</span> .hankel <span class="im">import</span> halfHankel</span>
<span id="cb15-4"><a href="#cb15-4"></a></span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="kw">def</span> texshadeSpatial(</span>
<span id="cb15-7"><a href="#cb15-7"></a>    x,</span>
<span id="cb15-8"><a href="#cb15-8"></a>    alpha: <span class="bu">float</span>,</span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="co"># halfHankel args</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>    nDiameter: <span class="bu">int</span>,</span>
<span id="cb15-11"><a href="#cb15-11"></a>    <span class="co"># halfHankel kwargs</span></span>
<span id="cb15-12"><a href="#cb15-12"></a>    interpMethod<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb15-13"><a href="#cb15-13"></a>    sampleSpacing<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb15-14"><a href="#cb15-14"></a>    hbTaps<span class="op">=</span><span class="dv">128</span>,</span>
<span id="cb15-15"><a href="#cb15-15"></a>    hbtransitionWidth<span class="op">=</span><span class="fl">0.03</span>,</span>
<span id="cb15-16"><a href="#cb15-16"></a>    <span class="co"># ols kwargs</span></span>
<span id="cb15-17"><a href="#cb15-17"></a>    size<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb15-18"><a href="#cb15-18"></a>    nfft<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb15-19"><a href="#cb15-19"></a>    out<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb15-20"><a href="#cb15-20"></a>):</span>
<span id="cb15-21"><a href="#cb15-21"></a></span>
<span id="cb15-22"><a href="#cb15-22"></a>  h <span class="op">=</span> halfHankel(</span>
<span id="cb15-23"><a href="#cb15-23"></a>      nDiameter,</span>
<span id="cb15-24"><a href="#cb15-24"></a>      alpha,</span>
<span id="cb15-25"><a href="#cb15-25"></a>      interpMethod<span class="op">=</span>interpMethod,</span>
<span id="cb15-26"><a href="#cb15-26"></a>      sampleSpacing<span class="op">=</span>sampleSpacing,</span>
<span id="cb15-27"><a href="#cb15-27"></a>      hbTaps<span class="op">=</span>hbTaps,</span>
<span id="cb15-28"><a href="#cb15-28"></a>      hbtransitionWidth<span class="op">=</span>hbtransitionWidth,</span>
<span id="cb15-29"><a href="#cb15-29"></a>  )</span>
<span id="cb15-30"><a href="#cb15-30"></a></span>
<span id="cb15-31"><a href="#cb15-31"></a>  <span class="cf">return</span> ols(x, h, size<span class="op">=</span>size, nfft<span class="op">=</span>nfft, out<span class="op">=</span>out)</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># export hankel-memmap.py</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="im">from</span> texshade <span class="im">import</span> texshadeSpatial</span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="im">import</span> postprocess</span>
<span id="cb16-5"><a href="#cb16-5"></a></span>
<span id="cb16-6"><a href="#cb16-6"></a>fname <span class="op">=</span> <span class="st">&#39;merged.tif.npy&#39;</span></span>
<span id="cb16-7"><a href="#cb16-7"></a>arr <span class="op">=</span> np.load(fname, mmap_mode<span class="op">=</span><span class="st">&#39;r&#39;</span>)</span>
<span id="cb16-8"><a href="#cb16-8"></a></span>
<span id="cb16-9"><a href="#cb16-9"></a>alpha <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb16-10"><a href="#cb16-10"></a>Nwidth <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb16-11"><a href="#cb16-11"></a>Nhalfband <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb16-12"><a href="#cb16-12"></a></span>
<span id="cb16-13"><a href="#cb16-13"></a>tex <span class="op">=</span> np.lib.<span class="bu">format</span>.open_memmap(<span class="st">&#39;mmap-tex.npy&#39;</span>, mode<span class="op">=</span><span class="st">&#39;w+&#39;</span>, dtype<span class="op">=</span>np.float64, shape<span class="op">=</span>arr.shape)</span>
<span id="cb16-14"><a href="#cb16-14"></a></span>
<span id="cb16-15"><a href="#cb16-15"></a>texshadeSpatial(arr, alpha, Nwidth, hbTaps<span class="op">=</span>Nhalfband, out<span class="op">=</span>tex, size<span class="op">=</span>[<span class="dv">2000</span>, <span class="dv">2000</span>])</span>
<span id="cb16-16"><a href="#cb16-16"></a></span>
<span id="cb16-17"><a href="#cb16-17"></a>postprocess.texToPng(</span>
<span id="cb16-18"><a href="#cb16-18"></a>    tex,</span>
<span id="cb16-19"><a href="#cb16-19"></a>    <span class="st">&#39;hankel-texshade-alpha-</span><span class="sc">{}</span><span class="st">-n-</span><span class="sc">{}</span><span class="st">-mmap.png&#39;</span>.<span class="bu">format</span>(alpha, Nwidth),</span>
<span id="cb16-20"><a href="#cb16-20"></a>    quantiles<span class="op">=</span>[.<span class="dv">01</span>, <span class="fl">.99</span>],</span>
<span id="cb16-21"><a href="#cb16-21"></a>    borderFractions<span class="op">=</span>[<span class="fl">1e-2</span>, <span class="fl">1e-2</span>])</span></code></pre></div>
<p>To downsample this large image for including with this repo:</p>
<pre><code>convert -filter Mitchell -sampling-factor 1x1 -quality 90 -resize 2048 hankel-texshade-alpha-0.8-n-500-mmap.png hankel-texshade-alpha-0.8-n-500-mmap.png.small.png</code></pre>
<p><img src="hankel-texshade-alpha-0.8-n-500-mmap.png.small.png" alt="Memory-efficient tex-shading via memory-mapped files and overlap-save technique of fast convolution" /></p>
<p>This image is qualitatively identical to the original texture-shaded output <a href="#tex-shaded">previously shown</a> but to reemphasize: while the <a href="#tex-shaded">original</a> texture-shaded image involved slurping the entire dataset into memory, and then computing huge FFTs of it, the image just above, generated by the <code>hankel-memmap.py</code> script, sipped memory: it loaded the input array as a memory-mapped file, allocated the output as a memory-mapped file, and used a spatial-domain filter to approximate the frequency-domain operator in the original image. By using the overlap-save method of fast-convolution, the filter was applied on small chunks of the data.</p>
<p>We can finally run the texture-shading algorithm on enormous datasets without needing gargantuan amounts of memory.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>John Otander's <a href="http://markdowncss.github.io/retro/">Retro</a> CSS theme. KaTeX for rendering equations.</p>
